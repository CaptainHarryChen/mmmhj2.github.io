---
layout: post
title: "语法制导翻译——语法制导翻译方案"
---

## 语法制导的翻译方案

语法制导的翻译方案（Syntax-directed translation scheme, SDT），简称翻译方案，是用来实现语法制导定义的常见方法，其通过在产生式中嵌入程序片段（称为语义动作）来进行翻译。
任何一个SDT都可以通过先生成含有程序片段（把程序片段作为树的叶子节点）的语法分析树，然后前序遍历并执行遍历到的程序来实现。
当然，我们一般并不显式地构造语法分析树，因此我们着重关注两类可以在翻译过程中直接执行的SDT，这些SDT和SDD密切相关：

1. 基本文法（即不包括任何SDD或SDT的文法）可以用LR技术分析，且SDD是S-属性的；
2. 基本文法可以用LL技术分析，且SDD是L-属性的。

我们将介绍在这两种情况下如何把SDD转化成SDT，并在语法分析中直接执行，通常是在语义动作左侧的符号匹配后立刻执行。
我们可以用一种简单的方法判断SDT是否可以在某种语法分析中执行：
为每一个语义动作生成一个特殊的非终结符号$M$，其产生式只有$M \to \epsilon$，然后用这个终结符号替换语义动作。
如果新的文法可以用原来的语法分析技术识别，那么这个SDT就可以在这种语法分析中实现。

### 后缀翻译方案

我们将研究一种特殊的翻译方案：**后缀翻译方案**。
这种翻译方案的特点是所有语义动作都在产生式体最右侧。

一个S-属性的SDD在使用LR技术分析时就会生成这种翻译方案，此时*所有语义动作都会在发生规约时执行*。
为了在LR分析时实现这种翻译方案，我们必须在语法符号栈（状态栈）中引入更多的信息来储存属性。
对于简单的属性，我们可以直接把它放到栈中，但对于更复杂的属性，可能不得不用指针代替具体的值。

在进行LR分析时，栈中的元素一定是已经被语法分析器处理过的，因此它们的属性值都是已知的，我们可以直接用相对栈顶的位置来得到每个符号的属性值。
下面的例子说明了如何利用额外的栈计算每个文法符号的属性值。
$$
\begin{aligned}
    L &\to E \mathbf{n} &\{ \text{print(stack[top-1].val); top = top-1} \} \\
    E &\to E_1 + T  &\{ \text{stack[top-2].val = stack[top-2].val+stack[top].val; top=top-2} \} \\
    E &\to T  &\{  \} \\
    T &\to T_1 * F  &\{ \text{stack[top-2].val = stack[top-2].val*stack[top].val; top=top-2} \} \\
    T &\to F  &\{  \} \\
    F &\to (E)  &\{ stack[top-2].val = stack[top-1].val; top=top-2 \} \\
    F &\to \mathbf{digit}  &\{  \} \\
\end{aligned}
$$
正如上文所述，
值得注意的是有几个产生式附加的语义动作为空，这是因为它们的产生式头的属性直接继承了式体的属性。

### 内部带有语义动作的翻译方案

虽然后缀翻译方案很容易在LR分析中实现，我们还是需要关心那些产生式中带有语义动作的翻译方案。
根据定义，在语义动作右侧的文法符号被识别到（如果是终结符，就是识别到本身，如果是非终结符，就是识别到可以由它推导出的终结符号串）后，立刻执行。
假设产生式为$B \to X \{ a \} Y$，其中$\{a\}$为语义动作。
如果语法分析是自顶向下的，那么我们在试图展开$Y$之前（如果是非终结符）或是识别到$Y$之前（如果是终结符）执行语义动作；
而如果语法分析是自底向上的，那么我们在$X$出现在栈顶时执行语义动作。

需要注意，尽管所有SDT都可以通过先忽略语义动作并构造语法分析树，然后在语法分析树中插入语义动作，最后前序遍历并执行来实现，我们更关心那些可以一边翻译一边执行而不用生成语法分析树的SDT。
可惜的是，并非所有SDT都可以这样执行。
考虑下面这个SDT：
$$
\begin{aligned}
    L &\to E \mathbf{n} & \\
    E &\to \text{\{print('+')\}} E_1 + T \\
    E &\to T \\
    T &\to \text{\{print('*')\}} T_1 * F \\
    T &\to F \\
    F &\to (E)  \\
    F &\to \mathbf{digit} \text{\{print(digit.val)\}}
\end{aligned}
$$
这个SDT就不能在自顶向下或自底向上语法分析中执行，因为语法分析器在还没有确定使用哪个产生式之前就被要求打印运算符号。
如果我们用上面介绍过的判定规则把所有语义动作都用产生空串的非终结符替代，那么对一个LR分析器，它就会在处理单个数字的输入时陷入移入/规约冲突。

### 消除左递归

如果我们要使用LL语法分析方法进行语法分析，那么就需要消除这个文法中的左递归。
然而，消除左递归会导致原文法的结构被破坏，进而影响SDT的执行顺序。

如果我们只关心SDT中动作执行的顺序，而不要求动作求出正确的值，比如要求按顺序打印某些字符，那么这种转换还是相当简单的。
我们只需要把语义动作当作一个终结符号即可。

考虑下面这个左递归文法：
$$
\begin{aligned}
    E \quad &\to \quad E_1 + T \; \text{\{ print('+') \}} \\
    E \quad &\to \quad T
\end{aligned}
$$
回忆一下，对立即左递归$A \to A \alpha \vert \beta$，我们创建一个新的非终结符号$R \to \alpha R \vert \epsilon$，并把其产生式替换为$A \to \beta R$。
对上述文法，我们把语义动作视为非终结符号，然后直接用这个算法进行替换，即可得到：
$$
\begin{aligned}
    E \quad & \to \quad T R \\
    R \quad & \to \quad + T \; \text{ \{ print('+') \} } \; R \\
    R \quad & \to \quad \epsilon \\
\end{aligned}
$$

然而，如果SDT中执行的动作不仅需要以正确的顺序执行，还要求出正确的属性值，那么我们就不得不仔细考虑如何修改这些语义动作的顺序。
对S属性的SDD，我们总是可以通过将计算属性值的动作放在新产生式的适当的位置来构造出SDT。

我们只考虑单个递归产生式，单个非递归产生式，单个属性的情况。
考虑以下SDT：
$$
\begin{aligned}
    A \quad &\to \quad A_1 + Y \; \text{\{ A.a = g(A_1.a, Y.y) \}} \\
    A \quad &\to \quad X \; \text{\{ A.a = f(X.x) \}}
\end{aligned}
$$

我们知道，所谓左递归的消除，就是把语法树的左子树转换成右子树，因此，为了保证信息在不同子树之间的流通，我们需要引入继承属性。
除此之外，左子树的信息必须被传递到右子树的底部，然后通过一个综合属性返还给根节点。
对于消除左递归后的文法，其在使用产生式$ R \to \epsilon $时标志了递归的终止，因此我们在此节点的语义动作上把继承属性传递给综合属性，然后返还给根节点。
这个继承属性需要收集所有左子树的信息以便进行计算。
应用这些思想，我们可以设计出这个消除了左递归的文法：
$$
\begin{aligned}
    A \quad &\to \quad X \; \text{\{ R.i = f(X.x) \}} \; R \; \text{\{ A.a = R.s \}} \\
    R \quad &\to \quad Y \; \text{\{ R_1.i = g(R.i, Y.y)\}} \; R_1 \; \text{\{ R.s = R_1.s \}} \\
    R \quad &\to \quad \epsilon \; \text{\{ R.s = R.i \}}
\end{aligned}
$$
正如我们描述的那样，在运用$A \to X R$这一产生式时，我们把$X$的属性传递到$R$上。
然后，在运用$R \to Y R$这一产生式时，把$Y$和$R$的属性和收集到$R_1$上。
最后，在运用$R \to \epsilon$这一产生式时，把继承属性传给综合属性，并逐步回传给$A$。
