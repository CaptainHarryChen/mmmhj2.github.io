---
layout: post
title: "语法制导翻译——语法制导定义"
---

在这一部分，我们将主要介绍两种语法制导翻译的方法：语法制导定义和翻译方案。

语法制导定义通过为语法分析树的结点引入属性，并在翻译过程中计算属性值来执行翻译；
而翻译方案通过直接在产生式中嵌入语义动作来执行翻译。
语法制导定义通俗易懂，但效率较低，因此适合用来描述翻译过程；
而翻译方案效率高，通常用于翻译器的实现之中。

本部分中我们将先研究语法制导定义，给出如何计算各种属性的方法，然后研究用翻译方案和语法分析过程实现语法制导定义。
最简单、最通用的方法当然是先构造语法分析树，然后在树上进行计算，但是这样费时费力，因为需要先扫描一遍代码，再扫描一遍（甚至多遍）分析树。
本部分在此基础上主要研究两个特殊的情况：L（Left-to-right）属性翻译和S（Synthesis）属性翻译，这两者都不需要生成分析树就能计算所有属性。
其中L属性翻译可用在所有语法分析过程中。

## 语法制导定义

语法制导定义（Syntax-Directed Definition, SDD）是一个上下文无关文法、属性和规则的集合。
属性和一个文法符号（终结或非终结均可）相关，而规则和产生式相关。
这个如果文法符号`X`带有属性`a`，那么我们可把它记为`X.a`。
实现时可以把属性看作表示文法符号的记录（结构体）的数据字段或对象的成员变量。
这个变量可能有多种类型，诸如数字、（表示类型的）类型，引用或字符串等，这样的字符串可能很长，以用来表示中间代码。

### 继承属性和综合属性

文法符号对应的属性分为两种：
- **综合属性**指由其本身为头的产生式上的规则决定的属性，在语法分析树上只由其本身和子节点的属性决定；
- **继承属性**指由其*父节点*为头的产生式上的规则决定的属性，这种产生式必须包括此节点代表的文法符号，在语法分析树上只由其父节点、本身和兄弟节点的属性决定。

我们不允许结点上的继承属性通过子节点的属性来定义，但是我们允许综合属性通过其本身的继承属性计算，尽管这要求先计算继承属性，从而使综合属性依赖于子节点以外的结点。 

原则上我们可以把某个结点的所有子节点的属性拷贝到这个结点中，这样允许该节点的继承属性使用子节点的属性进行计算，而不仅仅限于其父节点、本身和兄弟节点。
实践中很少需要这种继承属性。

我们先研究只有继承属性的SDD（称为S-属性的SDD），且假设没有属性求值副作用，即不打印字符、不修改符号表等。

### 利用语法分析树求值

直接在语法分析树上求值有助于我们理解语法制导翻译，但是翻译器通常并不直接构造这样一棵树。
我们称在结点上标注了所有属性的值的语法分析树为**注释语法分析树**。

如果要求出某个结点的属性值，我们必须先求出它所依赖的所有属性。
如果一个SDD是S-属性的，那么求值还是非常简单的，只需要按自底向上的方式逐一求值即可，这可由后序遍历实现。
对于同时具有继承和综合属性的SDD，求解求值顺序是一个相对困难的问题，甚至完全可能存在循环依赖而无法求值的情况。
不幸的是，产生式对应的语法分析树和表达式对应的抽象语法树之间存在很大差别时，使用继承属性几乎是不可避免的。

考虑下面这个语法制导定义：
$$
\begin{aligned}
    & T \to F T^\prime
    & T^\prime.inh = F.val, \; T.val = T^\prime.syn \\
    & T^\prime \to * F T_1^\prime
    & T_1^\prime.inh = T^\prime.inh \times F.val, \; T^\prime.syn = T_1^\prime.syn \\
    & T^\prime \to \epsilon 
    & T^\prime.syn = T^\prime.inh \\
    & F \to \mathbf{digit} 
    & F.val = \mathbf{digit}.lexval
\end{aligned}
$$
这个翻译方案是典型的$T \to F \* F$的左递归消除后的版本。
由于其产生的语法分析树和抽象语法树相差较大，不得不使用继承属性。
这里我们在检测到乘号，即利用第二个产生式时，继承左侧结点的值并用来计算乘法。

我们接下来仔细研究属性的求值顺序。

## SDD的求值顺序

### 利用依赖图确定求值顺序

虽然如果只给出SDD，求解其求值顺序是困难的，但如果已经构造出了语法分析树，那么利用依赖图和拓扑排序可以确定树各个属性的求值顺序。

我们规定**依赖图**是这样一张有向图：
对每个语法分析树的结点，属于它的每个属性都有一个结点；
如果我们需要用某个结点$A$的属性来确定另一个结点$B$的属性，那么就从$A$到$B$连接一条有向边。

如果已经构造了语法分析树和依赖图，那么只需要使用**拓扑排序**就可以确定表达式的求值顺序了。
如果在拓扑排序中发现了环，那么就说明不存在可以求出某些属性的方法。

### S-属性和L-属性

对于某些特定的SDD，我们不需要构造语法分析树就可以直接求出属性值。
考虑到翻译时通常并不构造语法分析树，这种SDD对我们特别有吸引力。

我们此前已经见到过S属性的SDD了，这种SDD构造的任意语法分析树都可以用自底向上的方法求出所有属性值。
尤其重要的是，我们可以直接在LR语法分析（更一般地说，所有自底向上语法分析方法）中顺便求出所有的属性，因为自底向上的分析恰好对应对语法分析树的后序遍历。
在LR分析栈中存放额外的信息，即可在不构造语法分析树的情况下求出所有综合属性。
我们将在后面仔细介绍这一过程。

接下来我们主要介绍L属性的SDD，这种SDD也可以按特定的方法求出所有属性值，而且可用于绝大多数现有的语法。
如果一个SDD是L属性的，那么它的所有属性都必须满足以下性质：

- 要么这个属性是综合属性；
- 要么这个属性是继承属性，但是对它有以下要求：
  如果存在一个产生式$A \to X\_1 X\_2 \dots X\_n$，并且这个属性是产生式体中一个符号的属性，写作$X\_i.a$，那么这个属性只能依赖于：
  1. 产生式头的继承属性；
  2. 位于$X\_i$左侧的符号的继承或综合属性；
  3. $X\_i$本身的继承或综合属性，且依赖图中不存在环。

这相当于要求每个继承属性只能依赖于其**上面或左侧**的结点的属性值。
举例来说，我们上面举的例子中的SDD就是一个L-属性的SDD。
而任何包含下列产生式和规则的SDD都不可能是L-属性的：
$$
\begin{aligned}
    A \to B C \quad & A.s = B.b \\
    & B.i = f(C.c,A.s)
\end{aligned}
$$
因为在第二条语义规则中我们使用了$B$右侧的文法符号的属性值。

### 具有受控的副作用的语义规则

在实践中，语义规则可能产生一些副作用，比如打印输出或修改符号表，但我们此前并不考虑这些。
实际上，SDD在属性计算和翻译方案间找到一个平衡点。
对前者，我们说其没有副作用，并可以按任何和依赖图一致的顺序进行翻译；
对后者，其可以含有任何代码，但必须严格按从左至右的方式求值并执行。

我们用两种方法在SDD中执行带有副作用的动作：
1. 要求副作用不会对属性求值产生约束，即任何按照拓扑序进行的求值，在考虑到其可能的副作用的情况下，都能产生期望的结果；
2. 约束可能的求值顺序，使在剩下的顺序中，副作用不对求值产生影响。

## 应用语法制导定义

