---
layout: post
title: "计算机网络——链路层"
---

## 链路层概述

链路层承担以下工作：
1. *封装成帧*：每个网络层的数据报在经过物理链路传输之前，几乎所有链路层协议都会把它封装成**帧**（Frame）。
2. *链路接入*：**媒体访问控制**（Medium Access Control，MAC）是链路层的一部分，规定了帧在链路上的传输规则。
   - 对点对点链路，通常使用简单的*点对点协议*（Point-to-Point Protocol，PPP），仅需在链路空闲时发送PPP帧即可；
   - 当多个节点共享单个广播链路时，各种问题就会出现，此时我们使用*以太网*，以太网的帧有时也叫MAC帧，这是本文的主要内容；
   - 如果需要使用以太网接入点对点网络（如ASDL），则使用以太网上点对点协议（PPP over Ethernet，PPPoE）将PPP帧封装在以太网帧中，在以太网中搭建点对点隧道。
3. *可靠交付*：如同TCP一样，在多个节点之间移动链路层帧时，提供可靠交付服务的链路层协议保证不会产生差错。通常易出差错的链路（如无线链路）才提供这种服务，否则容易浪费性能。
4. *差错检测和纠正*：链路层通常提供机制检测帧中的比特差错，以防止转发出现差错的帧。链路层的差错检测通常更加复杂且用硬件实现，有些时候还提供从差错中恢复的能力。差错检测和纠正只是可靠交付服务的一个子集，因此尽管许多链路层协议提供差错检测，其仍不提供可靠交付服务。

链路层的主体部分实现在**网络适配器**（Network Adapter，又称**网络接口卡**，Network Interface Card，NIC）上。
这是主板上的一块专用芯片，因此，许多链路层功能实际上是由硬件实现的。
早年间这块芯片还是通过物理上分离的一张连接到总线上的*卡*实现的，现在的网卡通常直接综合在主板上，形成局域网在主板（LAN on motherboard）配置。

当然，并非所有传输层功能都位于硬件上。
传输层硬件必须通过总线和CPU通信，而CPU必须能够寻址到网卡并接受网卡的中断。
链路层的软件组件实现了高层功能，发送时需填充地址信息并激活控制器硬件，接收时需响应中断并把数据报交给上层协议。
链路层就是网络协议栈中软件和硬件交接的地方。

## 差错检测与纠正

链路层可能需要实现*比特级差错检测和纠正*，因此，为了保护比特免受差错，链路层发送端会增加**差错检测和修正比特**（Error Detection and Correction，EDC）来保护数据$D$。
由于比特差错的问题，接收方接收的数据可能不同于发送的，接收方在只能接收到可能被修改的数据$D^\prime$和$EDC^\prime$的情况下，必须能够探测出比特差错。
需要注意的是，出现了差错不一定代表能够检测到这个差错，也可能出现**未检出的比特差错**（Undetected bit error），而优秀的差错检测与纠正算法必须使这种事件发生的概率足够小。

我们将介绍三种常见的差错检测技术。

### 奇偶校验

差错检测的最简单方式之一就是加入一个**奇偶校验位**（Parity bit）。
以偶校验方案为例，假设要发送的信息为$d$比特，那么偶校验方案为数据附加一位，使得这$d+1$比特中1的个数恰好为偶数。
如数据`0111 0001 1010 1011`的校验位就是`1`。
奇校验方案则反之。

这种校验方案非常简单，然而如果出现了偶数个差错，就会导致其不能检出。
如果我们假设比特差错的概率小，且之间是独立事件，那么多个比特同时出现差错的概率是非常小的。
不幸的是，研究表明，差错通常聚集在一起，而不是独立发生，因此只使用一位的奇偶校验方案的漏检率可以达到50%。

接下来我们研究**二维奇偶校验**。
我们把数据依次排列成$i$行$j$列的二维表格，然后为表格的每一行和每一列计算校验位，这样就能产生$i+j+1$个校验位。
注意我们也要为产生的校验位计算校验位，因此会产生一个额外的位。
比如对于数据`101011111001110`，我们把它排列成三行五列，然后计算校验位：
```
1 0 1 0 1 | 1
1 1 1 1 0 | 0
0 1 1 1 0 | 1
----------+---
0 0 1 0 1 | 0
```
这种校验位不仅可以检测，还可以修复数据和校验位的单个比特的差错。
其也能检测分组中任何两个比特差错的任意组合，但不能修复。

接收方不仅能检测，还能修复差错比特的能力称为**前向纠错**（Forward Error Correction，FEC）。
这种技术很有价值，因为其能在接收端自发修复错误以避免重发，避免两倍RTT的时延。
这对实时网络或长传播时延的网络（如深空通信链路）非常有用。

### 校验和

在校验和技术中，$d$比特序列被视作$\lceil d/k \rceil$个$k$比特无符号数字的序列。
把这些数字加起来就形成了校验和。

此前我们介绍的**因特网检验和**（Internet checksum）就是基于这种方法。

校验和方法的分组开销相对较小，但是其提供的差错保护相对较弱。
相较于此后介绍的、常用于链路层的CRC方法，这种方法可以用软件相对快速的实现，而链路层则可以时延硬件进行更加复杂的计算。

### 循环冗余检测

如今计算机网络中通常广泛使用**循环冗余检测**（Cyclic Redundancy Check，CRC）编码进行差错检测。
这种编码将所有数字看作模二多项式域（记为$\mathbb{Z}_2[X]$）上的一个多项式，然后在这个多项式域上进行运算。
比如二进制数`11011`就被转换成多项式$X^4 + X^3 + X + 1$，注意到这个多项式的次数比位数少一。

回忆一下，在这个域上的加法相当于按位异或，任何数的相反数为其自身，而乘法相当于按位与。
比如我们尝试计算$(X^2+X)(X+1)$：
$$
(X^2 + X)(X + 1) \equiv X^3 + 2 X^2 + X \equiv X^3 + X \pmod 2
$$
这相当于计算二进制乘法：`110 * 11 = 1010`，注意这和一般的二进制乘法不同，因为进位方式不同。

注意到这个是一个域，因此其上常用的带余除法仍然成立。
实际上循环冗余检测基于以下带余除法：
$$
M(X) \cdot X^n = Q(X) \cdot G(X) + R(X)
$$
其中多项式$M(X)$就是原数据转化成的多项式，而$G(X)$称为**生成多项式**（Generator）。
显然，根据带余除法的性质，$\mathrm{deg}(R(X)) < \mathrm{deg}(G(X))$，这意味着余多项式代表的二进制数的位数一定小于生成多项式代表的二进制数的位数。
商多项式$Q(X)$没有实际用途。
让后我们进行移项：
$$
M(X) \cdot X^n - R(X) \equiv Q(X) \cdot G(X) \equiv 0 \pmod{G(X)}
$$
我们又知道$\mathbb{Z}_2[X]$上任何数的相反数为其自身，因此有：
$$
M(X) \cdot X^n + R(X) \equiv 0 \pmod{G(X)}
$$
出于计算上的简便，我们直接假设$n = \mathrm{deg}(G(X))$，这相当于直接把$n-1$位的余数附加到在原消息后。

我们通常使用`CRC-n`来表示一个CRC算法，这个表示法中的$n$和上式中的$n$相同。
由于附加的余数正好比运算多项式少一位，因此`CRC-n`使用一个$n$次生成多项式，实际上是一个$n+1$位的二进制数；
相对地余数是$n-1$次多项式，所以其对应的二进制数实际上是$n$位的。

发送方和接收方协商产生一个生成多项式，然后发送方先在消息后附加$n$个零，除以生成多项式计算余数$R(X)$，在余数前面填充$0$至$n-1$位然后直接替换附加的零。
接收方收到这个消息之后，直接把消息除以生成多项式$G(X)$，检查余数是否为零即可。
由于所有运算都和逻辑门对应，这个算法可以相对容易地用硬件计算。

链路层通常采用标准规定的`CRC-32`多项式，其二进制数表示为：
```
1 0000 0010 1100 0001 0001 1101 1011 0111
```

标准的CRC多项式经过精心选择，以探测出所有小于等于$n$位的连续差错。
此外，在适当的假设下，CRC能够以$1-\frac{1}{2^n}$的概率探测到更长的连续差错。
CRC还能探测出任何奇数个差错。

## 多路链路访问

对于*广播链路*（Broadcast link），一个至关重要的问题就是*多路访问问题*（Multiple access problem），即如何协调多个发送和接受信道的问题。
相对地，*点对点链路*（Point-to-point link）则不需要解决这些问题，因此相对简单。
计算机使用**多路访问协议**（Multiple access protocol）来协调解决这一问题。

这个问题的关键在于解决**碰撞**（collide）。
当多个节点同时发送帧时，从这个信道接受帧节点就会接收到多个混杂的帧，这通常导致没有一个接收端可以收到正常的帧，此时就称传输的帧在接收方处*碰撞*。
如果发生大量碰撞，则大量带宽将被浪费掉。

多路访问协议负责解决这种问题，我们通常将多路访问协议分为三种：*信道划分协议*（channel partitioning protocol）、*随机接入协议*（random access protocol）和*轮流协议*（taking-turns protocol）。

我们希望任何多路访问协议尽量满足以下要求：
1. 当仅有一个节点发送数据时，它应该利用整个信道的吞吐量；
2. 当$N$个节点发送数据时，一段较长时间内平均下来每个节点应该平分吞吐量；
3. 协议是分散的，即不会因为某一个节点的故障导致整个系统崩溃；
4. 协议是简单的，即不会花费大量性能。

### 信道划分协议

我们此前介绍电路交换时叙述的*时分多路复用*（TDM）和*频分多路复用*（FDM）都是信道划分协议。

时分多路复用将时间划分为等长的**时间帧**（time frame），然后把时间帧划分为**时隙**（Slot）。
每个节点分配一个时隙，然后仅在其时隙中发送信息。
时分多路复用非常公平且消除了碰撞，但是每个节点仅能使用自己的时隙，即使其他所有节点都不选择发送信息，从而造成大量的带宽浪费。

频分多路复用原理相似，只是其按照频率而非时间划分信道。
其优点和缺点都是相似的。

第三种信道划分协议是**码分多址**（Code Division Multiple Access，CDMA）。
这种协议为不同的节点分配不同的**编码**，然后每个节点使用唯一的编码来为其数据进行编码。
CDMA允许不同的节点*同时*传输，而相应的接收方，只要知道编码，就可以正确接收所有数据，而无论干扰如何。
这种方式曾经常用于军事，现在通常用于移动电话与蜂窝网络。
