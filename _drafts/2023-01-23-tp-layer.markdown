---
layout: post
title: "计算机网络——运输层"
---

## 传输层协议简述

本章中主要研究两种传输层协议：TCP协议和UDP协议。
传输层在协议栈中位于网络层之上，网络层提供了主机到主机的逻辑通信，而运输层提供了进程与进程之间的通信。

传输层明显地受制于网络层的功能，但是仍可以实现网络层不能保证的服务。
比如，如果网络层不能保证延迟和带宽，那么传输层协议也无能为力；
相对地，即使网络层是不可靠的，传输层也能实现可靠的通信。

最常见的网络层协议，即IP，仅提供**尽力而为的交付服务**（Best-effort delivery service），既不保证数据报的交付、不保证交付的顺序，也不保证完整性，因此其也被称为**不可靠服务**。
但是，IP模型为每一台端系统都分配唯一的IP地址，用来识别主机。
相对的，UDP也是不可靠的，而TCP则提供**可靠数据传输**。

## 多路复用与多路分解

正如我们之前介绍的，网络层提供了主机到主机的逻辑通信，而运输层提供了进程与进程之间的通信。
这意味着不同进程之间的通信需要共享相同的网络。
为了把不同进程之间的通信合并到的网络层基础中，所有运输层协议都必须实现**多路复用**（Multiplexing）和**多路分解**（Demultiplexing，也称分用）。

更准确地说，多路复用就是为每个数据块封装用于识别的首部信息而生成报文段。
相对地，多路分解就是通过报文段的首部信息把数据交付到正确的套接字中，从而交付到不同的进程中。

为了实现这一目标，每一个套接字连接都有唯一的标识符，即**端口号**，而每个报文段都含有关于端口号的信息，从而实现报文段和套接字的对应，

对无连接的运输层协议（如UDP协议），只需要知道*目的地的IP地址和端口号*就可以确定这个套接字。
具体而言，目的地的IP地址允许进行多路复用，所有到达同一IP地址的数据报使用同样的网络层基础；
相对地，到达目的地后，不同目的地端口号的数据报会到达不同的套接字。
尽管源端口号和源IP地址对运输层是不必要的，知道这些信息是有用的，因为收到信息后通常需要进行回复。

对有连接的运输层协议（如TCP协议），我们需要知道*目的地和源的IP地址和端口号*。
这是因为TCP服务器只使用一个端口号作为“欢迎套接字”（即调用`accept`时使用的套接字），在接受连接时还会根据源端口和源IP地址创建新的套接字（即`accept`返回的套接字）。
为了区别不同的客户创建连接时形成的套接字，使用源端口和源IP地址是不可或缺的。

## UDP协议

我们首先观察UDP协议，这几乎可以算最简单的传输层协议，其只进行最低限度的服务，只提供多路复用/分用和最简单的校验功能。
在使用UDP进行通讯时，两端之间不会进行握手，因此UDP是*无连接*的。

尽管不提供任何保证，UDP仍有一些优点，因此常常被选用：
1. 允许应用层对数据发送的精细控制；
2. 不需要建立连接，也不需要维护连接状态；
3. 首部开销小。

同时UDP也具有一些缺点，特别是大量的UDP流量拥塞会导致TCP降低发送速度，因为TCP具有拥塞控制协议。

当然，通过应用层的修改可以使使用UDP的应用享受可靠传输，但这会导致应用开发的难度增大。

### 为UDP计算校验和

根据RFC 1071，UDP使用反码（又名一补码）加法计算校验和。

首先，把所有8比特字节两两组合，变成16比特的字，如果只有奇数字节则填充零。
然后，把它们当作反码进行加法运算。
反码的加法运算有一个特点，即进位的为要绕回到最低位。
因此两个16比特反码`1011101110110101`和`1000111100001100`的和为`0100101011000010`。
这个校验机制只能验证信息的完整性，而不能进行纠错。
当发生损坏时，只能要么丢弃整个分组，要么发出警告。

## 可靠数据传输

我们接下来研究TCP的一个部分，即可靠的数据传输，是如何做到的。
我们只研究单向的数据传输，双向的传输本质上和两个单向传输没有任何区别，因为TCP/IP在概念上是全双工的。
我们使用*分组*而非*数据报*，因为这些技术不止在传输层有用，而是可通用于整个计算机网络。

### 停止并等待协议

#### 比特差错信道

对完全可靠的信道，我们只需要简单的发送或接收分组即可，此时不会发生差错，因此数据传输也是可靠的。

我们现在考虑不可靠的信道，更特殊的，我们考虑只会发生比特差错的信道，此时暂时不考虑丢包的问题。

我们只需要引入一对简单的肯定确认（positive ACKnowledgment）和否定确认（Negative AcKnowledgment）消息即可。
这个协议有以下三个要点：
1. **差错检测**：接收方必须有检测比特差错的能力，这可以通过类似上文UDP校验的算法实现。
2. **接收方反馈**：接收方必须向发送方反馈自己是否接收到正确的分组。这可以通过ACK和NAK分组实现，仅需一个比特。
3. **重发**：发送方接收到NAK消息后必须重发上一个报文。

值得注意的是，这个协议正常工作的前提是**停等的**（Stop and wait），这就是说发送发一次只发送一个分组，然后*停止并等待*接收方的ACK或NAK消息。
当发送方等待应答消息时，其不能从应用层接收更多的数据。

然而，这个协议依然具有致命的缺陷，即，如果回复的ACK或NAK消息受损，那么怎么办？
我们假设应答消息依然具有校验和，因此发送方可以发现应答消息损坏，此时有三种可能的方法：
1. 递归询问：发送方也向接收方发送NAK消息，要求对方重发。这次重发的NAK也可能损坏，因此这并非非常好的解决方案。
2. 增强校验和：强化校验和的算法使其具有纠错功能。如果不考虑丢包那么就能解决问题。
3. **冗余分组**：如果发现应答消息受损，之间重发上一个分组，无论应答是ACK还是NAK。

冗余分组似乎是最合适的方法，但是其仍然存在一些困难：
首先，冗余分组显然会浪费带宽；
其次，最主要的问题在于，由于消息损坏，接收方无法*事先*（A priori，先验的）知道某个分组是重发的还是新的。

为了解决这个问题，我们可以为分组附加一个**序号**（SEQuence number），而接收方只需要检查序号就能知道一个分组是新的还是重发的。

由于停等协议的特点，其一次至多只发送一个分组，因此我们只需要一比特的序号。
接收方只需要检查这次的序号是否和上次相同就能确定是否重发，而发送方重发时序号不变，发送新分组时把序号取反即可。
如果接收方本来期待序号为零的分组，而收到了序号为一的分组，那么可以确定这个分组是重发的，进而丢弃这个分组。
需要注意，无论分组序号如何，如果发现损坏则一律发送NAK要求重发。

我们还可以注意到一个细节，如果我们为应答分组也编上序号，那么NAK是不必要的。
实际上，发送端只关心上一个分组是否正常送达，并不关心其是否是冗余的。
因此，发送端只需要检查应答的分组和刚刚发送的分组序号是否一致即可确定是否要重发上一个分组。
如果发送端发收到了一个编号为零的未损坏ACK应答，那么有两种可能：
1. 发送端刚刚发送了一个编号为零的分组，分组正常送达（无论是否是冗余的），下一个发送编号为一的分组。
2. 发送端刚刚发送了一个编号为一的分组，接收端收到了损坏的分组，重发这个分组。

如果发送端收到一个损坏ACK应答，那么重发上一个分组，此时这个分组是冗余的，而接收方直接丢弃它并发送对应的ACK响应。

总结一下，我们假设有无限的分组等待发送，对发送端其只有三个动作：
1. 初始时，发送序号为零的分组；
2. 如果接受的ACK损坏或和才发送的分组序号不符，则重发上一个分组；
3. 如果接受的ACK序号和内容正常，那么序号取反（加一），然后发送下一个分组（或等待应用层产生下一个分组）。

对接收端只有两个动作，假设初始时期望收到序号为零的分组：
1. 如果收到的分组序号和期望的不一致或分组损坏，那么丢弃这个分组，发送期望序号取反（加一）的ACK分组；
2. 如果收到的分组序号和内容正常，那么接受这个分组，发送带有期望序号的ACK分组。

#### 丢包信道

现在我们考虑一个可能丢包的信道，此时我们必须加入某些机制来发现丢失的分组。
在这里，我们使用**定时器**来发现丢包。

具体而言，发送端在发送一个分组之后就启动定时器，然后如果接收到序号正确的ACK分组就停止并重置定时器，然后序号加一并继续发送下一个分组。
如果定时器超时了（通常通过中断或异常来实现），说明刚刚发出的分组或响应的ACK分组丢失了，就重发上一个分组。

如果ACK丢失或定时器时间过短，这种机制就会发送冗余的分组。
然而在上一种情况下构造的接收端程序可以处理这种分组，因此不需要改变接收端的程序。

此外，我们把所有重发的代码让定时器接管，如果收到错误的ACK则什么都不做，等待定时器超时。

总结一下，发送端这次有四个动作：
1. 初始时，发送序号为零的分组并启动定时器；
2. 如果定时器超时，那么重发上一个分组并重置定时器；
3. 如果接受的ACK损坏或序号不符，那么什么都不做；
4. 如果收到正常的ACK，那么停止定时器，序号取反（加一），并发送下一个分组（或等待应用层产生下一个分组）且启动新的定时器。
   
而接收端的动作和上文所述一致。

这种停等协议对丢包信道工作正常，但是对带宽的使用效率低且在分组失序的情况下会出现问题。

考虑下面这种情况：
1. 发送端发送一个序号为零的分组，然后因为超时又重发了一遍；
2. 接收端接收到第一个分组，并发送了`ACK 0`；
3. 发送端接受了接收端的`ACK 0`，然后发送了下一个序号为一的分组；
4. 接收端接收了第三个序号为一的分组，然后发送`ACK 1`；
5. 由于*失序*，发送端发送的第二个序号为零的分组现在才到达，接收端只能认为其是正确的下一个分组，从而产生问题。

通过增加序号空间，而不是仅仅使用一比特的信号，可以缓解失序的问题。
接下来介绍的流水线算法可以解决这些问题。

### 流水线

### 回退N步

### 选择重传

## TCP协议
