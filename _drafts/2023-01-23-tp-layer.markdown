---
layout: post
title: "计算机网络——运输层"
---

## 传输层协议简述

本章中主要研究两种传输层协议：TCP协议和UDP协议。
传输层在协议栈中位于网络层之上，网络层提供了主机到主机的逻辑通信，而运输层提供了进程与进程之间的通信。

传输层明显地受制于网络层的功能，但是仍可以实现网络层不能保证的服务。
比如，如果网络层不能保证延迟和带宽，那么传输层协议也无能为力；
相对地，即使网络层是不可靠的，传输层也能实现可靠的通信。

最常见的网络层协议，即IP，仅提供**尽力而为的交付服务**（Best-effort delivery service），既不保证数据报的交付、不保证交付的顺序，也不保证完整性，因此其也被称为**不可靠服务**。
但是，IP模型为每一台端系统都分配唯一的IP地址，用来识别主机。
相对的，UDP也是不可靠的，而TCP则提供**可靠数据传输**。

## 多路复用与多路分解

正如我们之前介绍的，网络层提供了主机到主机的逻辑通信，而运输层提供了进程与进程之间的通信。
这意味着不同进程之间的通信需要共享相同的网络。
为了把不同进程之间的通信合并到的网络层基础中，所有运输层协议都必须实现**多路复用**（Multiplexing）和**多路分解**（Demultiplexing，也称分用）。

更准确地说，多路复用就是为每个数据块封装用于识别的首部信息而生成报文段。
相对地，多路分解就是通过报文段的首部信息把数据交付到正确的套接字中，从而交付到不同的进程中。

为了实现这一目标，每一个套接字连接都有唯一的标识符，即**端口号**，而每个报文段都含有关于端口号的信息，从而实现报文段和套接字的对应，

对无连接的运输层协议（如UDP协议），只需要知道*目的地的IP地址和端口号*就可以确定这个套接字。
具体而言，目的地的IP地址允许进行多路复用，所有到达同一IP地址的数据报使用同样的网络层基础；
相对地，到达目的地后，不同目的地端口号的数据报会到达不同的套接字。
尽管源端口号和源IP地址对运输层是不必要的，知道这些信息是有用的，因为收到信息后通常需要进行回复。

对有连接的运输层协议（如TCP协议），我们需要知道*目的地和源的IP地址和端口号*。
这是因为TCP服务器只使用一个端口号作为“欢迎套接字”（即调用`accept`时使用的套接字），在接受连接时还会根据源端口和源IP地址创建新的套接字（即`accept`返回的套接字）。
为了区别不同的客户创建连接时形成的套接字，使用源端口和源IP地址是不可或缺的。

## UDP协议

我们首先观察UDP协议，这几乎可以算最简单的传输层协议，其只进行最低限度的服务，只提供多路复用/分用和最简单的校验功能。
在使用UDP进行通讯时，两端之间不会进行握手，因此UDP是*无连接*的。

尽管不提供任何保证，UDP仍有一些优点，因此常常被选用：
1. 允许应用层对数据发送的精细控制；
2. 不需要建立连接，也不需要维护连接状态；
3. 首部开销小。

同时UDP也具有一些缺点，特别是大量的UDP流量拥塞会导致TCP降低发送速度，因为TCP具有拥塞控制协议。

当然，通过应用层的修改可以使使用UDP的应用享受可靠传输，但这会导致应用开发的难度增大。

### 为UDP计算校验和

根据RFC 1071，UDP使用反码（又名一补码）加法计算校验和。

首先，把所有8比特字节两两组合，变成16比特的字，如果只有奇数字节则填充零。
然后，把它们当作反码进行加法运算。
反码的加法运算有一个特点，即进位的为要绕回到最低位。
因此两个16比特反码`1011101110110101`和`1000111100001100`的和为`0100101011000010`。
这个校验机制只能验证信息的完整性，而不能进行纠错。
当发生损坏时，只能要么丢弃整个分组，要么发出警告。

## 可靠数据传输

我们接下来研究TCP的一个部分，即可靠的数据传输，是如何做到的。
我们只研究单向的数据传输，双向的传输本质上和两个单向传输没有任何区别，因为TCP/IP在概念上是全双工的。
我们使用*分组*而非*数据报*，因为这些技术不止在传输层有用，而是可通用于整个计算机网络。

### 停止并等待协议

#### 比特差错信道

对完全可靠的信道，我们只需要简单的发送或接收分组即可，此时不会发生差错，因此数据传输也是可靠的。

我们现在考虑不可靠的信道，更特殊的，我们考虑只会发生比特差错的信道，此时暂时不考虑丢包的问题。

我们只需要引入一对简单的肯定确认（positive ACKnowledgment）和否定确认（Negative AcKnowledgment）消息即可。
这个协议有以下三个要点：
1. **差错检测**：接收方必须有检测比特差错的能力，这可以通过类似上文UDP校验的算法实现。
2. **接收方反馈**：接收方必须向发送方反馈自己是否接收到正确的分组。这可以通过ACK和NAK分组实现，仅需一个比特。
3. **重发**：发送方接收到NAK消息后必须重发上一个报文。

值得注意的是，这个协议正常工作的前提是**停等的**（Stop and wait），这就是说发送发一次只发送一个分组，然后*停止并等待*接收方的ACK或NAK消息。
当发送方等待应答消息时，其不能从应用层接收更多的数据。

然而，这个协议依然具有致命的缺陷，即，如果回复的ACK或NAK消息受损，那么怎么办？
我们假设应答消息依然具有校验和，因此发送方可以发现应答消息损坏，此时有三种可能的方法：
1. 递归询问：发送方也向接收方发送NAK消息，要求对方重发。这次重发的NAK也可能损坏，因此这并非非常好的解决方案。
2. 增强校验和：强化校验和的算法使其具有纠错功能。如果不考虑丢包那么就能解决问题。
3. **冗余分组**：如果发现应答消息受损，之间重发上一个分组，无论应答是ACK还是NAK。

冗余分组似乎是最合适的方法，但是其仍然存在一些困难：
首先，冗余分组显然会浪费带宽；
其次，最主要的问题在于，由于消息损坏，接收方无法*事先*（A priori，先验的）知道某个分组是重发的还是新的。

为了解决这个问题，我们可以为分组附加一个**序号**（SEQuence number），而接收方只需要检查序号就能知道一个分组是新的还是重发的。

由于停等协议的特点，其一次至多只发送一个分组，因此我们只需要一比特的序号。
接收方只需要检查这次的序号是否和上次相同就能确定是否重发，而发送方重发时序号不变，发送新分组时把序号取反即可。
如果接收方本来期待序号为零的分组，而收到了序号为一的分组，那么可以确定这个分组是重发的，进而丢弃这个分组。
需要注意，无论分组序号如何，如果发现损坏则一律发送NAK要求重发。

我们还可以注意到一个细节，如果我们为应答分组也编上序号，那么NAK是不必要的。
实际上，发送端只关心上一个分组是否正常送达，并不关心其是否是冗余的。
因此，发送端只需要检查应答的分组和刚刚发送的分组序号是否一致即可确定是否要重发上一个分组。
如果发送端发收到了一个编号为零的未损坏ACK应答，那么有两种可能：
1. 发送端刚刚发送了一个编号为零的分组，分组正常送达（无论是否是冗余的），下一个发送编号为一的分组。
2. 发送端刚刚发送了一个编号为一的分组，接收端收到了损坏的分组，重发这个分组。

如果发送端收到一个损坏ACK应答，那么重发这个分组，此时这个分组是冗余的，而接收方直接丢弃它并发送对应的ACK响应。

#### 丢包信道

### 流水线

### 回退N步

### 选择重传

## TCP协议
