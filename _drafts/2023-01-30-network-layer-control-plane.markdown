---
layout: post
title: "计算机网络——网络层：控制平面"
---

## 概述

在本文中，我们将研究网络层的控制平面：即路由器如何决定其转发表。
我们知道，计算转发表的方式主要有两种，即让路由器自发决定和通过逻辑集中式控制器计算。
前者需要路由器和其他网络中的路由通信以计算转发表，这是由路由器的控制平面通过OSPF和BGP等*路由选择算法*完成的，且已经在互联网上使用许久了。
后者需要路由器和*逻辑集中式路由选择控制器*通信，控制器通过某些协议和数据平面的*控制代理*（Control Agent）通信，然后由CA配置和管理转发表，这意味着路由器本身不具有控制平面的功能，而是完全交由服务器控制。
这种控制方法还允许转发表进行复杂的动作，正如前文末尾所述。
SDN就是采用的后者的控制逻辑，而且已经在ISP中得到广泛使用。

## 路由选择算法

在本节中，我们将概述路由选择算法，并介绍两种最简单的算法以明确其思想。
在之后的章节中，我们还将介绍两个实际使用在互联网中的算法：OSPF与BGP。

我们使用无向图$G = (V,E)$来代表网络，其中$V$是顶点（Vertex，也称节点，Node）集合，而$E$是边集合。
图中的顶点表示路由器，而边表示一条物理链路，因此我们假设这个图没有重边与自环。
这个无向图是带有边权的，用来表示开销，这个值可能表示链路的物理长度、金钱开销或速度。
我们用$c(x,y),\, x,y \in V$来表示两个点之间的边的权值或耗费。
特别地，如果两个顶点之间没有边，那么规定$c(x,y) = \infty$；
同时规定$c(x,x) = 0$。
若两个顶点之间存在一条边，那么我们称这两个点为**邻居**（Neighbor）。

我们规定**路径**（Path）为一个顶点的有限有序序列$(x\_1,x\_2,\cdots,x\_p)$，其中任意两个相邻的顶点都是邻居，即$(x\_i,x\_{i+1}) \in E$。
我们称节点$x\_1$为起点，$x\_p$为终点。
我们额外规定路径必须是*简单*的，即其顶点序列中不含有重复的顶点。
路径的权值就是其所有边的权值的总和。
对于联通的图，任意两点之间必然存在路径，而这些路径中权值最短者就是**最短路径**。

路由选择算法就是要求在这样的一张图上选择出给定起点和终点之间的一条路径，当然，我们希望路径的耗费越短越好。

总的来说，路由选择算法有三种分类方式：
1. 集中式和分散式：
   1. **集中式路由选择算法**使用完整的、全局性的信息计算从源到目的地之间的最短路径，这种算法可以在路由器的路由选择处理器中执行，也可以在某个集中的设备上进行。这种算法也叫**链路状态**（Link State，LS）算法。
   2. **分散式路由选择算法**以迭代、分布式的方法计算最短路径。单个路由器并不具有整个网络的状态信息，相对地，仅仅需要其邻居的信息即可工作。最常见的分散式算法为**距离向量**（Distance Vector，DV）算法。
2. 静态和动态：
   **静态路由选择算法**计算出的结果，即路由，随时间的变化较慢，通常仅由人工进行调整；
   而**动态路由选择算法**在进行路由时会因网络的流量负载或拓扑变化而快速做出反应。
3. 负载敏感与负载迟钝：
   **负载敏感算法**中的链路开销会考虑到底层链路的拥塞水平，从而趋向于避开拥塞的链路；
   **负载迟钝算法**中的链路开销不会动态考虑链路的拥塞水平。
   早期互联网采用负载敏感算法，但是产生了许多问题，因此当前流行的算法都是负载迟钝的。

### 链路状态算法

链路状态算法有许多，此处我们介绍最常见的Dijkstra算法。

在链路状态算法之中，路由选择处理器必须知晓网络拓扑和所有链路开销。
实践中，这通常是通过让每个节点向网络中其他所有节点广播自己的状态分组来完成的，这种算法称为*链路状态广播算法*。
之后我们要研究的OSPF就是基于这种算法。

简单回忆一下未加任何优化的Dijkstra算法：
```
记N'表示已发现最短路的顶点集合
将起点u加入N'
初始化从起点到所有顶点v的距离D(v)为c(u,v)

重复：
    寻找不在N'中且D(v)最小的节点w
    将w加入N'中
    对w的每个邻居v：
        若 D(w) + c(w,v) < D(v)：
            D(v) = D(w) + c(w,v)
            将到达v的最短路径的前驱结点更新为w
直到 N' = N
```

这个算法的时间复杂度为$\mathcal{O}(n^2)$。

#### 路由振荡

这个算法虽好，但在拥塞敏感的路由选择情况下会发生路由震荡。
我们假设如果一条链路出现拥塞，那么将其边权增加以反应耗费的增加。

现在，假设路由选择算法选择了两个节点之间的最短路，然后把分组通过这条路径路由。
如果大量的分组通过这条路径，就会导致拥塞，从而耗费增加。
当增加耗费达到一定程度后，这条路径就不再是最短路了，从而算法会选择其他路径路由。
但是，选择其他路径后，这条链路上的负载就下降了，因此它又可能变回最短路。

任何拥塞敏感或基于时延的路由算法都可能遭遇这个问题。
尽管固定边权就不会发生这种振荡，但这对于拥塞敏感算法是不可能的，因为没有其他办法可以绕开拥塞链路。
为此，另一种解决方案是避免让所有路由器同时运行LS算法，这样可以让不同的路由器选择不同的路径，从而避免大规模的路由振荡。
有趣的是，因特网上的路由器具有一定的*自同步*特性，即尽管起始时间不同，相同周期的算法执行会自发的变成同一时间执行。
通过让发送链路通告的时间随机化可以解决这个问题。

### 距离向量算法

距离向量算法本质上是分布式的Bellman-Ford算法，基于经典的Bellman-Ford方程：
$$
d_x(y) = \min_{c(x,v) < \infty}\left( c(x,v) + d_v(y) \right)
$$
即从$x$到$y$的最短距离等于从$x$到其邻居$v$的距离加上从$v$到$y$的最短距离的最小值。

这个方程不仅给出了计算最短路的方法，还给出了从$x$到$y$的最短路在起点处的后继，换句话说就是给出了转发表的表项。
$$
\text{令} v^* = \arg \min_{c(x,v) < \infty}\left( c(x,v) + d_v(y) \right) \text{，那么，} v^* \text{就是最短路在} x \text{处的后继}
$$

接下来我们将介绍距离向量（Distance Vector，DV）算法，就是基于这个方程的。
这个算法需要每个节点$x$保存以下三种信息：
1. 到每个邻居所需的划分$c(x,v)$；
2. 该节点自己的距离向量$\vec{D}_x = \left[ D_x(y), y \in V \right]$；
3. 每个邻居的距离向量$\vec{D}_v$。

距离向量就是某个节点到所有其他节点的最短距离的估计值，可以证明使用DV算法可使这个估计值收敛至准确值。
节点自己的距离距离向量用来保存结果并向其他节点转发；
每个邻居的距离向量是从其邻居处接收的，用于计算自己的距离向量。

算法的工作流程非常简单：
每个节点定时向其邻居发送自己的距离向量；
每个节点收到邻居的距离向量时，检查其是否和保存的副本不同，如果不同则根据Bellman-Ford方程重新计算自己的距离向量；
如果节点在计算距离向量后发现自己的距离向量也更新了，那么它也向其邻居发送新的距离向量。

这个算法的伪代码如下：
```
将自己的距离向量初始化为c(x,y)，若y不是邻居则值为正无穷
将邻居的距离向量初始化为无穷大
向每个邻居v发送自己的距离向量Dx

永远重复：
    等待 收到邻居的距离向量或发现到邻居的链路权值变化

    对每个结点y：
        对x的每个邻居v：
            Dx(y) = min(c(x,v) + Dv(y), Dx(y))
    
    若Dx(y)发生变化：
        向每个邻居v发送Dx
```

#### 无穷计数与毒性逆转

现在让我们考虑边权的动态变化。
假设现在有三台路由器$x, y, z$构成的网络，其中`x - y`、`y - z`和`x - z`的边权分别为4、1、50。
我们此后仅考虑计算从`y`到`x`的最短路，忽略`x`路由器上运行的算法，并假设边权变化之前已经完成了DV算法。

假设`x - y`的边权变为1，那么会依次发生以下事件：
1. `y`检测到边权变化，更新自己的距离向量并发送之；
2. `z`收到`y`更新的距离向量，因此也更新自己的距离向量，即$D_z(x)$变为2；
3. `y`收到`z`更新的距离向量，但自己的距离向量不再更新，因此不再发送距离向量。

不难发现边权的减少非常容易在网络之中传播。

现在假设`x - y`的边权变为60，此时从`y`到`x`的最短路变为`y - z - x`。
此时会发生大量的事件：
1. `y`检测到边权变化，$D_y(x)$ 现在变为 $c(y,z)+D_z(x) = 1+5 = 6$，然后发送其距离向量；
   - 值得注意的是，现在出现了**路由环路**，即`y`将分组路由至`z`，而`z`将仍分组路由至`y`。
2. `z`收到更新的距离向量，然后更新自己的距离向量，现在$D_z(x) = c(z,y)+D_y(x) = 1+6 = 7$，然后发送距离向量……

这个过程将不断重复，直到最终算出距离大约50为止。
显然这将浪费大量的时间，尤其是在更新前的次短链路非常长，而增量又非常小的情况。
这种问题被称为无穷计数（Count-to-infinity，数到无穷大）问题。

我们可以通过引入**毒性逆转**（Poisoned reverse）来缓解这个问题。
其思想相当简单：如果`z`选择通过`y`路由到`x`，那么在广播的距离向量中，其将设$D_z(x) = \infty$。

在最多只经过两个结点的无穷计数问题中，在第一步时，由于`y`选择路由至`z`，因此其将通报$D_y(x) = \infty$。
然后当`z`接收到这个通报后，因为从`y`到`x`的距离为无穷大（被*毒化*了），就不会选择将分组路由至`y`了。

如果环路涉及三个或更多结点，那么这个算法就不起作用了。

### 总结

我们从以下三个方面总结这两个算法：
1. *报文复杂性*：LS要求每个结点知道每条链路的状态，因此需要$\mathcal{O}\left(\left\| E \right\| \left\| V \right\|\right)$个报文；相对地，DV在每次迭代时才会在邻居之间交换报文。
2. *收敛速度*：如果使用未优化的Dijkstra算法，那么LS算法的时间复杂度为$\mathcal{O}\left( \left\| V \right\|^2 \right)$；相对地，DV算法的收敛速度具有很大的不确定性，且容易遭遇路由回路和无穷计数问题。
3. *健壮性*：LS算法使用全局信息，但是只计算自己的路由表，而且计算结果不会相互影响，因此健壮性较好；相对地，DV算法会向整个网络传播错误的计算结果。

## 基于AS的路由选择：OSPF与BGP

迄今为止，我们都把网络视作是由许多地位平等路由器相互连接组成的。
然而，如果真的如此，那么每个路由器中无论是保存其他路由器的存储空间，还是计算路径所需的时间，都是极其恐怖的。
为此，我们使用简单的分治策略，把路由器组织成**自治系统**（Autonomous System，AS）。

自治系统通常代表一个ISP或组织，在一个AS中，所有路由器使用相同的路由策略。
有些ISP维护一个巨大的AS，而有些将其网络划分为多个AS。
每个AS由全局唯一的AS号（ASN）标识，这个序号由ICANN分配。

AS之间也有链路连接，而在AS之中和AS之间使用不同的路由选择算法，分别称为*自治系统内部路由选择协议*和*自治系统间路由选择协议*。
目前最常见的AS中和AS间协议分别为OSPF和BGP。

根据AS使用两种不同的路由选择协议是基于以下考虑：
1. *策略与性能*：在AS间进行路由时，我们更加关心选择AS另一个的策略，比如，一个AS可能希望其流量必须经过或必须不经过某一组AS，而不考虑这种路径选择导致的性能问题；而在AS中路由时，性能是最主要的问题，我们只希望选择性能最好的路径。
2. *规模*：在AS间进行路由时，我们不得不考虑互联网的巨大规模；而在AS中路由时，这种问题可以得到缓解，因为如果AS过大，组织总是可以将其拆分成多个AS。

### 开放最短路优先

目前常用的AS内部路由选择协议为**开放最短路优先**（Open Shortest Path First，OSPF）和**中间系统到中间系统路由协议**（Intermediate System to Intermediate System，IS-IS），分别规定在[RFC 2328](https://www.rfc-editor.org/rfc/rfc2328.html)和[RFC 1142](https://www.rfc-editor.org/rfc/rfc1142.html)中。
本节主要介绍OSPF协议。

OSPF是一种链路状态协议，其通过洪泛链路状态信息进行通告，并使用Dijkstra算法求解路由。
和其他LS算法一样，其每个路由器内部都要维护整个自治系统的完整路由图，并在此图上运行算法。
Dijkstra是一个单源最短路径算法，因此其可以求出从该路由器出发到所有AS内部路由器的最短路径。
这些最短路径构成了以本路由器为根节点的一棵树，称为最短路径树（这与最小生成树不同）。

在OSPF中链路的权重是由网络管理员手动配置的。
如果设定所有权重相等，那么该算法就会找出跳数最短的路径；
如果设定权重反比于容量，那么算法就会避免易拥堵的链路。

OSPF向自治系统中所有其他路由器广播路由选择信息，而非仅仅向邻居发送信息。
当相邻链路发生变化或定时器到达时间（至少30分钟一次）时，就会进行广播。
OSPF报文直接承载在IP协议之上，而不使用TCP之类的运输层协议，其协议号为89。
因此，OSPF必须自己实现可靠通信等运输层服务，此外，OSPF还需要自己确定链路的情况。

OSPF有以下优点：
1. *安全*：OSPF可以鉴别路由器之间的交换，阻止伪造的路由信息；
2. *多路*：当存在多条开销相同的路径时，OSPF可以使用所有路径进行路由；
3. *多播*：OSPF通过简单的拓展即可进行多播路由选择，扩展后的协议称为多播OSPF（MOSPF）；
4. *分区*：OSPF支持对一个AS内进行分区，每个区域内使用OSPF进行路由，然后通过区域边界路由器（Area Border Router，ABR）为流向区域外的分组进行路由。分区中最重要的是主干区域（Backbone area），所有区域必须连接至主干区域，穿越区域的分组必须先发送至主干区域以防止路由环路，因此该区域包含所有区域边界路由器。

OSPF直接使用IP数据报，因此其早期版本不支持对IPv6的路由。
定义在[RFC 5340](https://www.rfc-editor.org/rfc/rfc5340.html)中的OSPF v3才加入了对IPv6的支持。
相对地，IS-IS直接工作在连接层，因此对网络的性质不敏感。

### 边界网关协议

目前最常用的AS间路由选择协议为**边界网关协议**（Border Gateway Protocol，BGP），考虑到当下互联网的结构，这个协议可以说是最重要的协议之一。

BGP负责为AS之间的分组进行路由计算，在这种计算中，BGP并不路由到一个具体的IP地址，而是路由到一个CIDR前缀，即路由到一个子网之中。
这和我们此前介绍的转发表格式相同，其中也是使用前缀进行匹配的。

为了达成计算转发表的任务，BGP提供两项服务：
1. 获得可达性信息：BGP允许每个子网向互联网的其他部分通告自己的存在，从而允许其他AS知道一个子网可达；
2. 确定最优路由：收到到达某个子网的通告之后，如果存在多条到达子网的路径，BGP必须决定使用哪些路径。

值得注意的是许多家用路由器并不具有BGP的实现，因为其不需要负责AS之间的路由。

#### 通告路由信息

对每个AS中的路由器，其要么是*网关路由器*（Gateway Router），即连接到其他AS中路由器的路由器，要么是*内部路由器*（Internal Router），即仅连接到同AS内路由器的路由器。

为了传播可达性信息，路由器使用BGP连接上的BGP会话。
在BGP中，每对路由器使用179端口上的TCP连接进行通信，这种连接（以及其上发送的所有报文）称为*BGP连接*。
跨越两个AS的网关路由器之间的BGP连接称为*外部BGP连接*（eBGP），而相同AS中任何路由器之间的连接称为*内部BGP连接*（iBGP）。
通常由物理链路直接连接的两个不同AS的网关路由器之间就会有一条eBGP连接；
而AS内部的路由器，两两之间都存在iBGP连接，如果由于规模过大而导致这种连接不可行，则可以使用路由反射器（Route reflector）或路由器联合（Router confederation）。
即使两者之间不存在物理链路，AS内路由选择协议允许两者建立逻辑连接。

BGP按以下规则传播通告报文：
从iBGP接收的报文仅会转发至eBGP连接；
从eBGP接收的报文既转发至iBGP连接，又会转发至eBGP连接。
从网关路由器发送至其他AS的BGP报文中会附加自己所在的AS信息，以确定路径。

BGP报文由一个前缀和多个*属性*组成，其中最重要的属性为`AS-PATH`和`NEXT-HOP`。
`AS-PATH`指明了当前报文的传播路径，每当该报文被网关路由器转发至其他AS，就会在其中附上自己的AS信息；
`NEXT-HOP`指明了`AS-PATH`起始的路由器接口的IP地址，也就是上一个转发的网关路由器所用接口的IP地址，这个信息用来确定向哪个路由器发送被路由的分组。
`AS-PATH`也用来检测并组织环路。
具体而言，如果接受报文的路由器发现自己所在的AS已经出现在该属性中，就会拒绝转发此报文。

假设存在三个互相连接的AS，即AS 1连接至AS 2，AS 2连接至AS 3，AS 3又连接至AS 1。
如果AS 3中存在一个子网`x`，那么AS 3的网关路由器会向AS 2和AS 1的相邻网关路由器发送BGP报文`x; AS-PATH: AS3`，以告知它们子网`x`可通过AS 3路由达到。
此外，每个发送此报文的网关路由器还要将所用接口的IP地址附加在`NEXT-HOP`属性中。
AS 2的网关路由器接受的这个报文后，把这个报文通过iBGP向所有同AS的路由器（包括网关和内部路由器）转发，因此所有路由器都有这条链路的信息了。
然后，AS 2到AS 1的网关路由器通过iBGP收到这个报文并通过eBGP转发至AS 1中。
转发之前其会在`AS-PATH`中附加`AS2`，同时修改`NEXT-HOP`为自己转发所用接口的IP地址。
对AS 1，其也会收到AS 3直接发送的报文，因此所有AS 1中的路由器都知道两条到达子网`x`的路径：
1. 通过AS 2与AS 1相连的网关路由器到达AS 2，然后再到达AS 3；
2. 通过AS 3与AS 1相连的网关路由器直接到达AS 3。

#### 路由选择

现在我们考虑如何构造转发表。
我们先以最简单的路由选择算法，即**热土豆路由选择**（Hot potato，意为“烫手山芋”）开始。

正如其名暗示，热土豆路由选择把分组看作“烫手山芋”，除非自己就是目的地，否则尽快地（使用最低耗费）将分组送出自己所在的AS。
不难发现，为了尽快送出分组，我们需要使用AS内部路由选择协议。
具体而言，整个转发表的构造使用以下四步：
1. 从AS间协议获取到达子网的路径信息；
2. 从AS内协议获取到达其他AS中的网关路由器的链路信息；
3. 利用热土豆路由选择，选择其中耗费最低的网关作为出口；
4. 利用自己的转发表（由AS内协议构造）确定通往该网关的出口接口，然后填入转发表中。

在确定路由之前，路由器必须保证`NEXT-HOP`中的那个网关路由器是*可达*的，即其已经存在与自己的路由表中。
这通常需要手动配置。
根据使用的AS内部路由选择协议，可能只需要配置网关路由器即可。
假如使用OSPF，则仅需要把`NEXT-HOP`中的网关路由器加入骨干网。
也可以让收到`NEXT-HOP`中的那个网关路由器在通过iBGP传播报文时将`NEXT-HOP`修改为自己，这样内部路由器都会转发至同AS的网关路由器。

实际上的BGP路由选择必须考虑的*策略*（Policy）问题。

有些网络通常只作为流量的起点或终点，比如一个家庭或企业的内部网络，这种网络称为*桩网络*（Stub network）。
假设一个桩网络同时接入多个ISP，即构成*多宿接入桩网络*（Multi-homed stub network）。
显然，多宿接入的网络可以作为分组路由的途径，两个ISP之间的流量原则上可以经过这种网络。
但是我们并不希望如此做，首先这种网络的承载能力有限，其次可能是出于商业上或是安全上的考量。

除此之外，当两个ISP之间存在多个路径时，如果选择这些路径也是值得考虑的问题。
这些路径会经过不同的AS，这些AS可能属于不同的ISP，因此会带来商业上的问题。
目前通用的经验法则是不将流量路由到非源或目的地所在的ISP中，但两个ISP之间具体使用什么方式进行路由则更多的是一个商业问题而非技术问题。

回到BGP来，为了将策略纳入考虑，简单的路由选择算法显然是不足的，实际上，BGP依次使用以下方法确定路由：
1. 使用**本地偏好**（Local preference）属性；
2. 使用距离向量算法选择`AS-PATH`最短的路径；
3. 使用热土豆路由选择算法；
4. 使用BGP标识符进行选择。

#### IP任播

BGP可用于实现IP任播。
在这种情况下，多个服务器使用相同的IP地址，而根据路由不同，从不同地点出发的流量将进入任何一个服务器之中。
由于BGP算法原则上会选择最优的路由路径，利用其实现的IP任播可以用来为不同的地理位置提供不同的内容，或是为每个用户提供速度最优的内容。

这种IP任播方式实际上用于实现DNS根服务器的镜像。
我们知道根服务器只有13个不同的IP地址，而通过IP任播，任何组织实际上都可以搭建一个DNS根服务器的镜像。
