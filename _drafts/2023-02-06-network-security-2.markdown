---
layout: post
title: "计算机网络——网络安全②"
---


## 报文完整性和数字签名

我们已经考察了密码学如何为通信提供机密性，现在让我们来关系其如何保证**报文完整性**（Message integrity）。

具体而言，如果Bob接到自称来自Alice的报文，那么他需要验证：
1. 该报文的确来自Alice；
2. 该报文没有被其他人（如Trudy）篡改。

对称加密在一定程度上可以做到这一点，但密码学提供了更加强力的工具：密码散列函数。

### 密码散列函数

**散列函数**（Hash function，也叫哈希函数或杂凑函数）以报文$m$为输入，计算并得到一个称为*散列*（或称哈希、杂凑）的长度固定为$n$比特的字符串。
此前讲过的互联网检验和和CRC都满足这个定义。
**密码散列函数**（Cryptographic hash function）还要满足以下性质：
1. 和任何性质好的散列函数一样，对任何随机输入报文$m$，其散列的任何一位为指定值（零或一）的概率为$2^{-n}$；
2. 难以（计算上不可行）从给定的散列值计算原报文（即原像）；
3. 给定一个报文，难以（计算上不可行）找到另一串不同的报文，使两个报文的散列值相同。

互联网校验和显然不满足这个定义，因为其仅执行加法，从而对报文的顺序不敏感。
比如，我们按16比特进行分块，假设一个字符占8比特并用ASCII编码，然后计算反码加法，那么`aabb`和`bbaa`的检验和就是相同的。

现在常用的密码散列函数包含[RFC 1321](https://www.rfc-editor.org/rfc/rfc1321)中标准化的*MD5算法*。
其由Ron Rivest在1991年发明，用来替代更早的MD4标准。
这种算法将数据分为512比特的分块，并给出一个128比特的散列。
尽管这种算法早在1993就被发现了碰撞（即两个不同的IV产生相同的散列值），并被发现了多种安全漏洞，其仍然被广泛使用。
这种算法虽然不足以对抗恶意的攻击，但仍可以保证数据不受无意的破坏。

此外最流行的密码散列函数为**安全散列算法**（Security Hash Algorithm，SHA），这族算法包括多个不同的算法，从SHA-0到SHA-3。
目前常用的为SHA-1，版本管理工具Git就使用它区分不同的提交。
这种算法在2017年也被发现了碰撞。

### 报文鉴别码

直接为报文计算其散列值并附在报文后虽然可以避免报文本身被修改，但是完全不能避免攻击者替换报文并重新计算散列值。
为了保证报文的完整性，除了使用密码散列函数之外，还需要一个**鉴别密钥**（Authentication key）。
Alice和Bob共享这个鉴别密钥，就像对称加密里那样。

在发送报文时，Alice并不简单地计算报文的密码散列函数，而是计算把报文和鉴别密钥连接在一起，然后计算整体的散列值，再把这个散列值附在报文后面。
这个散列值称为**报文鉴别码**（Message Authenticated Code，MAC）。
Bob收到报文和散列值后，把重复以上步骤，然后检验自己计算的散列值与附在报文后的散列值是否相同即可。

报文鉴别码虽然也要使用一个密钥，但是其并不需要使用加密算法对报文进行加密。
如果通信端不关系机密性，只需要保证完整性，那么就可以使用这种方法。

目前报文鉴别码最常用的标准为**基于散列的报文鉴别码**（Hash-based Message Authentication Code，HMAC）。
这种标准可以和MD5或SHA-1等散列算法一同使用。

现在我们来考虑如何分发鉴别密钥的问题。
考虑为路由器分发用于OSPF报文鉴别的鉴别密钥。
这个密钥可以使用硬件手动分发，也可以为每个路由器分配一个公钥，然后为使用这个公钥加密鉴别密钥，然后进行分发。
