---
layout: post
title: "计算机网络——网络安全②"
---


## 报文完整性和数字签名

我们已经考察了密码学如何为通信提供机密性，现在让我们来关系其如何保证**报文完整性**（Message integrity）。

具体而言，如果Bob接到自称来自Alice的报文，那么他需要验证：
1. 该报文的确来自Alice；
2. 该报文没有被其他人（如Trudy）篡改。

对称加密在一定程度上可以做到这一点，但密码学提供了更加强力的工具：密码散列函数。

### 密码散列函数

**散列函数**（Hash function，也叫哈希函数或杂凑函数）以报文$m$为输入，计算并得到一个称为*散列*（或称哈希、杂凑）的长度固定为$n$比特的字符串。
此前讲过的互联网检验和和CRC都满足这个定义。
**密码散列函数**（Cryptographic hash function）还要满足以下性质：
1. 对任何随机输入报文$m$，其散列的任何一位为指定值（零或一）的概率为$2^{-n}$；
2. 难以（计算上不可行）从给定的散列值计算原报文（即原像）；
3. 给定一个报文，难以（计算上不可行）找到另一串不同的报文，使两个报文的散列值相同。

前两条要求和“性质好”的散列函数的要求类似，即“好”的散列函数通常也满足这两条。
第三条要求则是密码散列函数独有的，如果出现两个不同的报文产生相同的散列值，则称发生了**碰撞**（Collision）。
一般的散列函数通常也需要避免碰撞，但通常只需要避免无恶意的碰撞，比如电信号的错误；
而密码散列函数则需要抵抗恶意构造的碰撞攻击，如果能够很容易地构造一个碰撞，那么这个散列函数就不是密码学安全的。
安全散列算法的散列值也叫做**摘要**（Digest）。

互联网校验和显然不满足这个定义，因为其仅执行加法，从而对报文的顺序不敏感。
比如，我们按16比特进行分块，假设一个字符占8比特并用ASCII编码，然后计算反码加法，那么`aabb`和`bbaa`的检验和就是相同的。

现在常用的密码散列函数包含[RFC 1321](https://www.rfc-editor.org/rfc/rfc1321)中标准化的*MD5算法*。
其由Ron Rivest在1991年发明，用来替代更早的MD4标准。
这种算法将数据分为512比特的分块，并给出一个128比特的摘要。
尽管这种算法早在1993就被发现了碰撞（即两个不同的IV产生相同的散列值），并被发现了多种安全漏洞，其仍然被广泛使用。
这种算法虽然不足以对抗恶意的攻击，但仍可以保证数据不受无意的破坏。

此外最流行的密码散列函数为**安全散列算法**（Security Hash Algorithm，SHA），这族算法包括多个不同的算法，从SHA-0到SHA-3。
目前常用的为SHA-1，版本管理工具Git就使用它区分不同的提交。
SHA-1生成一个160比特的摘要。
这种算法在2017年也被发现了碰撞。

### 报文鉴别码

直接为报文计算其散列值并附在报文后虽然可以避免报文本身被修改，但是完全不能避免攻击者替换报文并重新计算散列值。
为了保证报文的完整性，除了使用密码散列函数之外，还需要一个**鉴别密钥**（Authentication key）。
Alice和Bob共享这个鉴别密钥，就像对称加密里那样。

在发送报文时，Alice并不简单地计算报文的密码散列函数，而是计算把报文和鉴别密钥连接在一起，然后计算整体的散列值，再把这个散列值附在报文后面。
这个散列值称为**报文鉴别码**（Message Authenticated Code，MAC）。
Bob收到报文和散列值后，把重复以上步骤，然后检验自己计算的散列值与附在报文后的散列值是否相同即可。
此前提到的OSPF就使用报文鉴别码保证报文的完整性。

报文鉴别码虽然也要使用一个密钥，但是其并不需要使用加密算法对报文进行加密。
如果通信端不关系机密性，只需要保证完整性，那么就可以使用这种方法。

目前报文鉴别码最常用的标准为**基于散列的报文鉴别码**（Hash-based Message Authentication Code，HMAC）。
这种标准可以和MD5或SHA-1等散列算法一同使用。

现在我们来考虑如何分发鉴别密钥的问题。
考虑为路由器分发用于OSPF报文鉴别的鉴别密钥。
这个密钥可以使用硬件手动分发，也可以为每个路由器分配一个公钥，然后为使用这个公钥加密鉴别密钥，然后进行分发。

### 数字签名

如同在现实中进行签名一样，在数字领域，我们也需要一些手段证明某个文件的所有者或创作者是某人，或是表明他认可文件的内容，这可通过**数字签名**（Digital signature）实现。
数字签名应当和现实的签名一样可以鉴别且不可伪造，即可以证明有且仅有指定的人可以签署这个文件。

此前介绍的MAC并不足以实现数字签名，因为通信的两方都具有鉴别密钥，从而都可以计算MAC，因此不具有唯一性。
相对地，公钥密码是实现数字签名的绝佳手段，这是因为公钥密码系统的特性，即$K\_B^-(K\_B^+(m)) = K\_B^+(K\_B^-(m)) = m$。
回忆一下，在RSA中，公钥和私钥实际上是指数，而由于同余环的乘法分配性，交换它们不会导致结果的改变。
交换公钥和私钥可以得出相同的结果，这意味着发送方Bob可以使用自己的私钥计算签名的报文，然后任何人都可以使用公钥解密得到正常的报文。

这种方法能够保证唯一性和不可伪造性，因为能够解密出正确的报文说明加密过程使用了私钥，而原则上只有Bob本人具有私钥。
如果篡改了源文档，那么签名当然是无效的，因为解密出的报文和原报文不能对应。

为整个报文进行加密需要花费大量的时间，因此我们可以加密报文的散列值。
散列函数能把任何场地的报文转换成相同长度的散列值，且散列值通常远远小于报文，因此可以降低加密解密算法的时间。
因此，我们在计算签名时，不需要计算$K\_B^-(m)$，而是计算$K\_B^-(H(m))$即可，其中$H$是一个散列函数。
这个被加密的报文摘要就可以称为**数字签名**。
Bob只需要把数字签名附在报文后面即可。

验证这个数字签名时，Alice首先利用公钥解密数字签名，得到报文的摘要。
然后，她使用相同的散列函数计算报文的摘要，然后比较两个摘要，只要相同就可以证明这个数字签名是有效的。

数字签名提供比报文鉴别码更强大的保证。
相对地，MAC在生成过程中不使用任何加密或解密过程，因此速度更快。
如果需要广泛地使用数字签名，那么就需要广泛地启用公钥加密，为此需要专门的**公钥基础设施**（Public Key Infrastructure，PKI）。

#### 公钥认证

数字签名的重要用途之一就是认证公钥确实属于某个特定的实体，这称为**公钥认证**（Public key authentication）。

数字签名确实可以确保报文来自其自称的发送者，且报文未受篡改，但是只凭借发送方和接收方两方，不能保证其自称的发送者就是真正的发送者。
假设Trudy使用自己的私钥对一个报文进行签名，然后把报文和公钥发送给Alice，并自称是Bob发送的。
Alice只能凭借报文做出决定，她用公钥成功验证了这个报文未受篡改，但是没有办法验证这个报文确实是Bob发送的，除非她事先能够知道Bob的公钥（如同向Github添加GPG公钥，或是为SSH添加密钥那样），或是有其他办法确定一个公钥是否真的属于其自称那一方（如同我们将要介绍的那样）。

将公钥与实体绑定的工作通常是由**认证中心**（Certification Authority，CA）进行的。
CA具有以下功能：
1. 证实一个实体的真实身份。CA只负责证实网络实体与网络真实身份的对应关系，而如何证实现实实体与网络实体的对应关系则不是一个密码学问题。
2. CA证实身份后，便会生成一个把实体和公钥绑定起来的证书。这个证书包括公钥和标识实体的一些的标识信息（如域名、IP地址、姓名等）。CA负责用自己的*私钥*对这个证书进行数字签名。

如何利用公钥认证确定公钥确实属于某个实体呢？
Bob使用完全相同的方式进行数字签名，唯一不同的是，Bob不发送其公钥，而是发送其证书。
这个证书，正如前文所述，既含有公钥，又含有CA的数字签名。
Alice收到报文和证书后，使用CA的公钥验证其公钥确实和Bob对应，然后再使用Bob的公钥验证报文的完整性。

CA的公钥（和证书一起）通常是提前安装到计算机之中的，在Windows中可以使用证书管理器（`certlm.msc`）查看。

国际电信联盟（International Telecommunication Union，ITU）和互联网工程任务组（Internet Engineering Task Force，IETF，负责维护RFC）分别提出了ITU X.509和RFC 1422作为基于CA的证书管理规范。
