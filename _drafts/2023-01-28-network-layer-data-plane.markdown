---
layout: post
title: "计算机网络——网络层：数据平面"
---

## 网络层概述

网络层只承担两个功能：**转发**（Forwarding）和**路由选择**（Routing）。

- 转发指分组到达路由器的输入链路时，路由器必须选择把该分组移动到正确的输出链路；
- 路由选择指网络层必须为所有从一个端系统到另一个端系统的分组决定经过的路径。

这两个功能分别构成网络层的数据平面和控制平面，维系两个功能的中介叫做**转发表**（Forwarding table）。
工作在控制平面的**路由选择算法**通过各种方式决定数据包经过的路径，然后为数据平面填充转发表。
路由器根据数据报的首部查询转发表，并决定使用哪个输出端口。

转发表可以由技术人员手工填写，而更传统的方法是使用一些方法由路由器自行决定。
除此之外，转发表也可以由一个远程控制器填写，这种方法称为软件定义网络（Software-Defined Networking，SDN）。

如果让路由器自行决定，那么其会通过特别的分组收集网络中其他路由器的信息，并保存在*路由表*（Routing table）中
我们将在研究控制平面时详细研究这些算法。

除了网络层的转发表和路由表外，在链路层还有ARP表和交换表，这些表容易混淆。
我们将在研究链路层时再介绍这两种表。

### 网络服务模型

网络服务模型定义了端到端之间传输的特性，包括但不限于：
- 确保交付；
- 时延上界；
- 有序交付；
- 最小带宽；
- 安全性。

可惜的是互联网最常用的网络层协议，即**互联网协议**（Internet Protocol，IP），只提供**尽力而为**的服务，也就是*并不提供任何一种服务*。
当然有一些其他的网络体系结构和对应的协议可以提供更多的服务，但实践已经证明IP*足够好*。

### 数据平面与路由器

本章考察网络层中的数据平面，包括路由器和转发的工作原理，包括IP寻址以及IPv4和v6两个协议。

我们不加区分“转发”（Forwarding）和“交换”（Switching）两个术语。
值得注意的是另外两个易于混淆的术语：*交换机*（Switch）和*路由器*（Router）。
我们约定，**分组交换机**，简称交换机，是指所有从输入链路读取分组然后根据首部字段将它们转移到输出链路的设备。

交换机又细分成两种：**链路层交换机**（Link-layer switch，又称第二层交换机）和**路由器**。
前者根据链路层帧进行转发，后者根据网络层数据报进行转发。
随着科技进步又出现了第三种设备：*第三层交换机*（或称多层交换机，Multilayer switch），其本质上是在链路层交换机上附加部分路由器的功能，以在性能和价格之间取得平衡。

自然，本章中我们主要研究路由器。

## 路由器工作原理

路由器主要由四个组件构成：
1. *输入端口*：输入物理链路的终点；负责接收分组并从中提取足够的信息以进行转发，这通过查询转发表实现；负责与链路层交互以执行链路层功能；负责控制分组进入交换结构，最终从输出端口输出。
2. *交换结构*：负责在输入端口和输出端口之间传递分组。
3. *输出端口*：输出物理链路的起点；也执行相关的链路层功能。
4. *路由选择处理器*：执行路由选择协议并填充转发表，在SDN中负责和服务器通信。

以上三个组件有且仅有路由选择处理器位于控制平面，其他三个都位于数据平面。
数据平面的三个组件通常直接由硬件实现，因此其时间仅有纳秒级；
相对地，控制平面的工作周期通常可达秒级。

常见的转发具有两种形式：
*基于目的地的转发*只查看IP数据报头部的目的地字段，然后进行转发；
*通用转发*根据数据报头部的各种字段以及网络的其他信息进行转发。

### 输入与输出端口

输入端口含有三个组成部分：
1. 线路端接：物理链路的接口；
2. 数据链路处理：进行链路层的处理，然后将链路层帧拆封成网络层数据报；
3. 转发：根据数据报查找转发表，然后进行转发，如果交换结构被占用则还需要在此排队。

转发表使用前缀匹配来节省空间，当有多个匹配时选择最长的匹配规则。
比如，前缀`11001000 0001011 00011000`可以匹配所有以这三个字节开头的目的地址。
如果一个地址同时还匹配前缀`11001000 00010111 00011`，那么这个地址会匹配前者，因为前者的匹配前缀最长。

为了在纳秒级别完成转发表的查询，路由器使用DRAM甚至SRAM来进行查找。
除此之外，部分路由器还会使用*三态内容寻址储存器*（TCAM）进行查找。

尽管查找和转发是输入端口最重要的功能，其他功能也有相当重要的地位。
除此之外，输入端口可能还要负责其他功能，比如在*网络地址转换*中，输入端口还要负责根据端口号修改接收地址等。

相比之下，输出端口则相对比较简单，其也有三个部分，分别负责排队、链路层处理和端接。

### 交换结构

路由器中常见的交换结构有三种：
1. *内存*：类似计算机，输入端口把数据报放入内存，然后输出端口读取内存。
2. *总线*：使用一条总线连接所有输入和输出端口，结构简单但效率较低，因为同时只能传输一个分组。
3. *互联网络*：通过复杂的线路网络将端口连接在一起，最常见的是纵横式交换结构。
   线路之间的交叉由包含在交换结构之中的控制器控制。
   纵横式交换结构是非阻塞的，其中的分组如果不到达同一出口就不会相互阻塞。

### 队列与调度

在输入和输出端口都存在队列，因此不难想见两者都会发生排队，而队列空间耗尽后还会发生*丢包*。

如果交换结构的速度不足以处理所有进入的分组，那么在输入端口就会发生排队。
有些时候，尤其是使用非阻塞交换结构的时候，先到达的分组可能因为输出端口被占用而发生排队。
尽管后到达的分组所需的输出端口并未被占用，因此可以立刻被发送到输出端口，其仍然被阻塞在队列之中。
这种现象称为**线路前部**（Head-Of-the-Line，HOL）阻塞。

相对地，如果输出链路的速度不足以接收所有被转发到的分组，那么在输出链路上也会发生排队。
如果没有足够的内存来储存新到达的分组，那么必须丢弃至少一个分组。
如果丢弃新到达的分组，那么这种策略被称为“弃尾”，除此之外，也可以选择丢弃队列中的分组。
还有一些控制策略并不等到队列已满再做出决定，相对的，其在缓存填满之前就进行丢弃，这种策略称为**主动队列管理**，其中最广泛研究的算法为随机早期检测。

当输出（或输入）队列中不止一个分组时，如何选择下一个处理的分组也是值得考虑的问题，这个问题就是经典的*调度问题*。
最常见的调度方式有三种：
1. 队列调度，即先进先出或先到先得调度。
2. 优先队列调度：为高优先级和低优先级分配不同的队列，然后同优先级的分组以队列方式调度。
   - 可能是抢占式的或非抢占式的，前者在高优先级分组到达时会停止正在传输的低优先级分组，后者则不停止。
3. 轮询（Round robin）调度：分组按某些规则分类，然后按类型依次得到处理。
   - 这种调度中可以加入加权优先，这种*加权公平排队*是最常用的调度算法。

## 网际协议

### IPv4 数据报

根据[RFC 791](https://www.rfc-editor.org/rfc/rfc791)，典型的IPv4数据报头部如下所示：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

1. 版本号（Version）表示了IP协议的版本。
2. 首部长度（Internet Header Length，IHL），按32比特为一字计算的首部长度，这一段是必要的，因为选项是变长的。如果不含有选项，那么典型的长度为20字节，此处值为5。
3. 服务类型（Type Of Service，TOS）用于区别对IP有不同要求的数据报，比如要求实时的VoIP数据报。
4. 总长度（Total Length）即数据报的长度，单位为字节。
5. 标识（Identification）、标志（Flags）和片偏移（Fragment Offset）与分片有关，我们之后再仔细介绍。
6. 存活时间（Time To Live，TTL）每次被路由器处理时减一，到达零时会被导致数据报丢弃，用于防止数据报在网络中永远循环。
7. 协议（Protocol）标识载荷中保存的报文段的协议，在数据报到达端系统后，端系统使用协议字段来将其分发到指定的运输层协议。
8. 首部校验和（Header Checksum），按和UDP相同的反码加法计算的首部的校验和，和运输层不同，这个校验和只计算首部而不计算载荷。
9. 源地址和目的地址（Source\Destination Address）。
10. 选项（Options）可选变长的选项，很少使用。
11. 填充（Padding）用于将数据对齐至4字节。

值得一提的是，典型的IP首部为20字节，而典型的TCP首部也是20字节，因此MSS比MTU少40字节。

### 分片

我们之前已经介绍过，根据链路层的不同，不同的网络具有不同的最大传输单元（MTU）。
如果一个路由器需要向MTU小于当前数据报大小的输出链路发出数据报，那么IPv4规定其必须将较大的数据报分割为更小的片。

分片是通过设置标识、标志和片偏移实现的。
在产生数据报时，发送端必须为数据报分配一个唯一的标识并填充到首部的标识字段中，通常这是通过在上一个数据报的标识上加一实现的。
当路由器需要进行分片时，其根据每一片的偏移设置片偏移，并将最后一片的标志的某一位（参见RFC 791）设为一。
首部的一些字段被复制，而一些字段仅出现在第一个分片中。

分片的组装仅在接收端发生，而途径的其他所有路由器都不会进行组装，因为这会消耗大量的性能。
通过片偏移和标志位，接收端可以把所有分片正确组装起来（如果没有发生丢包）。
组装分片时也使用了一个定时器来探测丢失的分片，如果定时器超时，那么立刻释放所有分片，然后视作整个数据报丢失。

### 寻址

通常计算机通过接口（Interface）接入网络，接口一般位于网络接口控制器（Network Interface Controller，通称网卡）上。
相对地，路由器也通过接口接入网络。
对同一网络中的接口，每个不同的接口必须具有不同的IP地址。
值得强调的是，在*不使用NAT*的情况下，实际上每个接口必须具有*全互联网唯一*的IP地址。

对IPv4，IP地址长度为32比特，即四个字节，通常以**点分十进制**（Dotted-decimal）方式写出，即每个字节用十进制书写，然后按大端在前的方式用点分割。

因特网使用**无类别域间路由选择**（Classless InterDomain Routing，CIDR）来划分*子网*并进行寻址。
当使用子网寻址时，32位的IP地址被划分为两个部分，写作`a.b.c.d/x`的形式。
其中`x`指示了地址的第一部分，称为**子网掩码**，标识整个IP地址的前`x`位是*子网地址*，也称*前缀*。
所有子网地址相同的接口构成了一个*子网*，相对地，所有希望接入某个子网的接口也必须具有相同的子网地址。
而剩余的`32-x`比特用于区分一个子网的不同内部设备，只有在网络内部转发分组时才会使用这些比特。
这些比特可能又定义了不同的子网，比如某个组织的地址可能为`a.b.c.d/21`，而其中某个分部的子网可能具有`a.b.c.d/24`的形式，其中前21位是相同的。

我们此前提到路由器使用前缀进行匹配，这和子网的概念暗合。
实际上，在控制平面的路由选择协议BGP中，子网外的路由器只考虑一个地址的前缀，而完全不考虑其他部分，这有助于减少路由表和转发表的长度。
路由器正是根据子网地址决定将分组转发到哪个接口的，这个过程不断重复直至到达与目标接口相邻的那个路由器，然后发送到对应接口的。

相对地，最长前缀匹配原则也发挥不小的作用。
假设一个ISP利用*路由聚合*为连接到它的所有组织分配地址。
这就是说，ISP自己申请`200.23.16.0/20`这样的大子网，然后为连接到它的组织分配`200.23.16.0/24`这样的小子网。
然后，如果一个组织希望转移其ISP，那么它仅需要让新的ISP申请将`200.23.16.0/24`这个小子网路由到它即可，而不必修改其他任何设置。
当分组进行路由时，由于最长前缀匹配，该组织的分组只会被路由到新的ISP中，因为后一个前缀更长。

所谓无类别，是相对于**分类编址**（Classful addressing）的。
在采用CIDR前，IP地址的子网部分仅有8、16或24比特四种，分别称为A、B、C类网络（还有保留的D类和E类网络）。
这种方式过于不灵活，因此已经弃用。

有两个特殊的地址：0.0.0.0和255.255.255.255，分别表示“本机”和“同网络所有主机”（广播）。
这两个地址仅在特殊情况下（如DHCP）才会使用。
大部分路由器不会把后者这种分组发送到其他子网去。

#### 获取IP地址

和DNS类似，IP地址也是使用分层的方式分配的。
如果一个组织希望分配一块IP地址作为其子网，其必须向ISP申请，ISP进而从其已经申请的地址块中分配一块。
ISP的地址耗尽以后，又必须向更上一层的ISP申请。
最终，所有IP地址都是由一个非营利性组织“互联网名称与数字地址分配机构”（Internet Corporation for Assigned Names and Numbers，ICANN）管理的。
这个组织也负责管理域名的分配。

现在考虑单个主机的IP地址分配。
原则上，网络管理员可以手动为每个主机分配并设定其IP地址，但是这样无疑是对人力的巨大浪费。
为此，人们提出了**动态主机配置协议**（Dynamic Host Configuration Protocol，DHCP）来动态地为主机分配临时的IP地址。
这一协议的标准为[RFC 2131](https://www.rfc-editor.org/rfc/rfc2131)。

这一协议由四个步骤组成，均使用UDP：
1. *DHCP服务器发现*：新接入的主机发送源地址为`0.0.0.0`，目的地为`255.255.255.255`，目的端口为67的UDP报文，这个分组被广播至所有同网络主机，其中包括DHCP服务器。
2. *DHCP服务器提供*：服务器收到发现报文时，发送源地址为本机IP地址、目的地为`255.255.255.255`的UDP广播报文，报文中包括分配的IP地址、子网掩码、租期、等信息。
3. *DHCP请求*：新接入的主机收到提供报文时（可能有多个提供报文，因为可能有多个DHCP服务器），从中选择一个，然后发送对应的DHCP请求报文，请求使用某个IP配置。注意此时服务器尚且没有确认这个请求，因此源地址依然为`0.0.0.0`，目的地为`255.255.255.255`，以通知所有DHCP服务器。
4. *DHCP应答*：收到DHCP请求后，对应的服务器发送DHCP应答以确认（依然是广播），然后客户端就可以使用这个地址了。

值得注意的是所有发送的分组都是广播分组，而客户的地址总是`0.0.0.0`，这是因为直到DHCP应答为止，客户的IP地址都是不确定的。

### 网络地址转换

IPv4地址仅有约四十亿个，如果我们要求每个接口都具有全互联网唯一的地址，那么IP地址早就耗尽了。
为了尽可能解决这个问题而不使用新的网络协议（IPv6协议已经解决了这个问题），不得不重用部分地址，这就是通过**网络地址转换**实现的。
其标准为[RFC 3022](https://www.rfc-editor.org/rfc/rfc3022)。

IANA（ICANN的一个部门）在IP地址池中保留了三块**专用网络**地址：
```
     10.0.0.0        -   10.255.255.255  (10/8)
     172.16.0.0      -   172.31.255.255  (172.16/12)
     192.168.0.0     -   192.168.255.255 (192.168/16)
```
这些地址不会在互联网上出现，因此可以安全地用作子网中的地址，而不会干扰其他路由。
相对地，这些地址也仅在一个网络之中有意义，仅有在同一个网络中的主机才能使用这些地址通信。
因此，这些地址才被称为*专用的*。

这些地址的复用是通过网络地址转换实现的。
对一个启用网络地址转换的路由器，其虽然只在互联网上占用一个地址（这个地址通常是ISP使用DHCP分配的），因此似乎只是一个设备，但是却负责把进入该路由器的分组翻译并分发到该子网的其他主机上，从而代替了子网中的所有设备。

这种翻译是通过**NAT转换表**实现的。
NAT转换表中的一项是由广域网端地址和端口号和局域网端地址和端口号组成的四元组。

当局域网中的主机发起到广域网中主机的连接时，路由器把局域网端主机的地址和端口号记录在表中，然后生成一个新的端口，并把这个端口和路由器广域网端接口（应当转发至的那个接口）的地址填入刚刚生成的表项中。
然后，路由器把所有从局域网端发出的数据报，如果其发送端和转换表的局域网端匹配，就将其源地址替换为路由器的地址，源端口替换成刚刚生成的端口，转发替换后的分组；
对所有从广域网端收到的数据报，如果其接收端和转换表的广域网端匹配，就把它的目的地址替换成局域网端的地址，目的端口替换成局域网端的端口即可。

注意到NAT并不关心广域网端服务器的地址或接收端口，这会使NAT翻译非当前套接字的分组，只要目的地址和端口号匹配。

对于从局域网发出的分组，NAT不修改其目的地信息；
对于从广域网接收的分组，NAT不修改其发送端信息，因此NAT对于两端都是透明的。

这种转换导致整个子网对广域网不透明，从而导致了多种问题，比如在不加特别处理的情况下，从广域网发起的连接不能到达局域网的主机，因为NAT表中没有对应的项。
造成这一问题的根本原因是NAT的寻址单位为进程，而非主机，在进程没有发出要求的前提下，不会进行NAT转换。
针对这一问题，我们可以提前配置转发表（路由器中的“端口转发”设置）或使用NAT穿越（内网穿透）工具，UPnP（通用即插即用）协议也允许主机发现并配置邻近的NAT。

这一协议也会导致协议栈的混淆，因为路由器工作在网络层，但是NAT要求它修改传输层的数据（即TCP、UDP的端口号）。
