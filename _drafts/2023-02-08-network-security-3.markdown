---
layout: post
title: "计算机网络——网络安全③"
---

## 连接层安全性：安全套接字层

TCP使用一个强化版本提供机密性、数据完整性和端点鉴别（鉴别客户端和服务器），称为**安全套接字层**（Secure Socket Layer，SSL）。
SSL的第三版的一个改进版称为**运输层安全性**（Transport Layer Security，TLS），已经由IETF标准化在[RFC 8446](https://www.rfc-editor.org/rfc/rfc8446)中。
SSL得到广泛应用，并且已经被大部分互联网上的网站所支持，因为HTTP服务正是运行在TCP之上。

SSL原则上工作在应用层，但对应用程序而言，其实际上提供一个控制安全套接字的接口，和TCP的接口非常类似，因此对于应用程序其实际上位于连接层和应用层之间。
我们称SSL是工作在应用程序与连接层之间的一个子层，其仍然属于应用层。

### 工作流程

我们将大致介绍SSL的工作流程。
SSL具有三个阶段：握手、密钥导出和数据传输，前两个阶段也可以统称握手。
我们假设Bob向Alice发起连接，Alice作为服务器应当具有一个带有公钥的证书和对应的私钥。

#### 握手与密钥导出

首先介绍握手阶段，此时客户端Bob需要建立TCP连接、验证Alice的身份然后生成并发送**主密钥**（Master Secret，MS）。
主密钥在此后的密钥导出中用于生成其他密钥。
首先Bob进行典型的TCP三次握手并建立TCP连接。
如果成功建立连接，则Bob发送`ClientHello`报文请求建立SSL连接，其中包括自己期望的加密算法等参数和一个随机不重数。
服务器以证书和一些其他内容回复，包括：
一个`ServerHello`报文，其中包括服务器选择的加密算法，包括一个对称加密算法，一个公钥加密算法（或密钥交换算法）和一个MAC及签名算法，通称*加密套件*（Cipher suite）；
一个`Certificate`报文，包括服务器的证书，根据加密套件不同可能不发送证书；
一个`ServerKeyExchange`报文，用于进行密钥交换，如果加密套件不使用密钥交换算法则不发送此报文；
一个`ServerHelloEnd`报文，标志回复的结束。

客户端验证证书的正确性，然后回复一个`ClientKeyExchange`报文，含有*前主密钥*（Pre-Master Secret，PMS）、公钥等内容，这个内容是由加密套件指定的。
前主密钥需要使用从证书中提取的服务器公钥进行加密。

服务端收到加密的前主密钥后，进行解密得到PMS。
然后，客户端和服务端各自独立地根据PMS和不重数导出主密钥，然后根据主密钥生成两个会话加密密钥和两个鉴别密钥。
会话加密密钥用于会话的对称加密，由Bob发送的数据和由Alice发送的数据使用不同的密钥；
同理，鉴别密钥用于生成MAC，两端也使用不同的密钥。
使用不同的密钥更加安全。

如果对称加密使用密码块链接（CBC），那么两端的两个初始向量（IV）也由主密钥获得。

最后两端发送所有握手报文的MAC以免受篡改。
客户端首先发送`ChangeCipherSpec`报文，标识此后的内容都已经加密且被验证，然后发送一个`Finish`报文，其中含有MAC。
服务端接收此报文并验证上述所有报文的MAC，如果发现不符则终止连接。
服务端也发送这两个报文供客户端验证。

上文介绍的握手基于公钥加密进行主密钥的产生，使用密钥交换算法的时候，其步骤略有不同，但是基本思路是一致的。
如果不是服务端具有证书，而是客户端具有证书，那么握手的过程也会发生变化。

#### 数据传输

TCP是一种字节流协议，因此使用SSL进行加密的自然方法就是使用SSL在传输中加密数据，然后再将加密的字节流发送给TCP层。
但是，如果只发送加密的字节流，那么就无法使用MAC验证报文的完整性了。
为此，SSL使用一种称为**记录**（Record）的方式传输数据。

每一个SSL记录含有报文类型，SSL版本，报文长度，数据和MAC五个组件。
记录中数据和MAC使用发送方的密钥进行加密，而剩下三个不加密。

值得注意的是，TCP的报文首部是没有加密的，因此如果只对数据计算MAC，那么这种方案不能应对重排序攻击。
这种攻击调整TCP首部的序号，如果每个TCP报文段只含有一个记录，这会使得接收方收到顺序错误的记录，而这些记录都可以正确解密。
解决这个问题的关键在于为每个记录分配一个序号，每一端发送一个记录后就将自己的序号加一。
Alice和Bob分别维护自己和对方的序号，但不在报文中包括这个序号，而是在计算MAC时同时计算记录和序号的MAC。
因此，任何一端都可以同时使用维护的对方的序号和数据计算MAC，然后验证正确性。

#### 连接关闭

SSL实质上不能对**截断攻击**（Truncation attack）进行任何保护，因为其基于TCP，而TCP连接只需要发送未经保护的`FIN`报文就会被终止。
为了稍微缓解这种攻击，SSL使用一个特殊的关闭通知（Close notify）记录。
这是一大类警报记录中的一种，警报记录还负责通知诸如MAC错误之类的问题。
尽管修改未经保护的SSL记录的类型字段是相当容易的，但是这种修改会导致MAC验证失效。

这种缓解方案仍然不能对抗中间人发送的`FIN`报文攻击，但是如果一端在没有收到关闭通知的情况下发现TCP连接关闭，那么就可以认为是恶意的攻击。

大部分应用程序使用额外的方法保证信息不会被截断，如HTTP首部的`Content-length`字段。
除此之外，不使用关闭通知的连接关闭实在非常常见，比如移动设备离开WiFi范围导致的物理链路被切断，因此大部分应用程序实际上不对错误的TCP`FIN`报文段做出任何响应。
