---
layout: post
title: "词法分析——有限自动机进阶"
---

## 有穷自动机的时间复杂度

我们设正则表达式为$r$，其大小为$\left\| r \right\|$。
正则表达式的大小是其运算符和运算分量的长度的总和。
输入串为$x$，其长度为$\left\| x \right\|$。
那么NFA和DFA的时间复杂度如下表所示：

| 自动机 | 构造自动机 | 识别字符串 |
| ------ | ---------- | ---------- |
| NFA | $\mathcal O ( \|r\| )$ | $\mathcal O ( \|r\| \times \|x\| )$ |
| DFA（平均） | $\mathcal O ( \|r\|^3 )$ | $\mathcal O ( \| x \| )$ |
| DFA（最坏） | $\mathcal O ( \|r\|^2 2^{\|r\|} )$ | $\mathcal O ( \| x \| )$ | 

不难发现，NFA的构造非常迅速，而DFA的识别更加快速。
因此，对于有大规模输入的词法分析器，我们通常使用DFA而非NFA；
而对于只使用一次的情况，如`grep`命令，则通常采用NFA。

还有一种方法可以实现NFA和DFA的折中：使用记忆化方法。
我们先构造NFA，然后记录用到的状态集合和其转移。
如果再遇到同样的状态集合，就不用重新计算了。

## 用于词法分析器的有穷自动机

我们此前介绍的NFA和DFA已经足以用来识别所有用于词法分析的模式。
然而要用这些自动机来解决词法分析仍然需要一些补充。
本节将解决这些问题。

### 基于NFA的词法分析

为了利用NFA进行词法分析，首先我们需要解决如何同时匹配多个正则表达式的问题。
我们可以先把每个正则表达式的NFA构造出来，构造一个新的开始状态，然后用标号为空串的边把每个正则表达式的NFA的开始状态连接起来。

下图就是一个可识别`a`、`abb`和`a*b+`的NFA，注意`a*b+`的NFA不是用前一篇文章中的算法构造出来的。

![](/assets/compilers/trans-merged-nfa.svg)
{: .center-image}

现在我们还需要解决优先级的问题。
对于字符串`abbbbb`，三个正则表达式都可以识别，此时应输出哪个词法单元呢？
通常来说，我们优先识别前缀最长的，也就是`a*b+`。
如果此时仍然存在多个可识别的表达式，那么我们按照给出的先后顺序识别。
如果字符串为`abb`，那么识别`abb`而非`a*b+`。

现在我们给出一个算法用来处理这种情况。

在模拟NFA时，我们保存途径的所有状态和转移。
模拟过程中，我们总是会到达一个状态，此时再输入一个符号就会导致当前状态集合为空（也就是前一个状态集合中所有状态都没有可用的转移）。
这个时候，我们就沿着保存的状态向前查找，直到找到至少一个接受状态为止。

比如我们用上述NFA识别`aaba`这个字符串，其途径的状态分别为：
$$
\{0,1,3,7\} \xrightarrow{a} 
\{2,4,7\} \xrightarrow{a} 
\{7\} \xrightarrow{b} 
\{8\} \xrightarrow{a} 
$$
到达8这个状态之后，对给定的输入已经没有可转移的状态了。
此时我们沿着路径向前寻找，可以发现两个接受状态（2和8）。
最靠近末尾的状态是8，对应识别`a*b+`。
如果最后含有接受状态的状态集合中含有多个接受状态，那么我们按接受状态对应的表达式的先后顺序识别即可。

#### 基于DFA的词法分析

我们已经知道，在词法分析中通常使用DFA而非NFA，现在我们考虑如何把上面的讨论应用到DFA上。
实际上，我们只要把维护状态集合的路径变成维护状态的路径即可。
严格地说，对DFA，不存在没有可用转移的情况，而是以一个特殊的状态取而代之（参见上一篇文章），我们把这个状态称为**死状态**，用空集符号表示。
我们会在DFA的优化一节中详细讨论死状态的产生与消除。

除此之外，如果这个DFA是由NFA生成的，那么在构造DFA的接受状态时还要记录对应的正则表达式。
回忆一下，从NFA生成DFA时，只要DFA的状态对应的NFA的状态集合中含有至少一个接受状态，那么对应DFA的状态也是接受状态。
这个时候，我们需要把NFA的状态集合中的所有接受状态对应的正则表达式都记录到DFA对应状态中。
可能会出现一个DFA接受状态对应多个正则表达式的情况，这个时候我们还是优先识别在正则定义中先出现的。
比如在上述NFA生成DFA时，会产生一个状态，其对应状态集合为$\\\{6,8\\\}$，这个状态既能接受`abb`又能接受`a*b+`，因此在DFA中是一个接受状态。
因为`abb`先出现，因此DFA中这个状态接受的模式为`abb`。

我们知道，如果按照上述算法执行直到没有转移（转移到死状态），那么一定会匹配最长的前缀。
我们又保证了最长前缀对应多个表达式时优先匹配先出现的，因此这个算法的优先级和此前定义的一样。

我们用生成的DFA匹配相同的字符串，其状态路径为：
$$
0137 \xrightarrow{a} 
247 \xrightarrow{a} 
7 \xrightarrow{b} 
8 \xrightarrow{a} 
\emptyset
$$
此处状态$0137$表示由NFA中状态集合$\\\{0,1,3,7\\\}$生成的DFA状态。
到达空状态后我们沿着路径回溯，可以发现第一个接受状态为$8$，对应正则表达式为`a*b+`。

### 向前看运算符

有些时候，我们需要知道一个词素后面紧跟着的部分，才能判定这个词素的语法单元名，这种情况尤其容易出现在关键字不是保留字的语言中。
比如在Fortran中，`IF(I,J)=3`表示对名为`IF`的数组赋值，而`IF ( condition ) THEN`才是条件判断语句。
如果要识别这种词素，我们必须知道`IF`后面的部分。
这个时候，我们需要引入**向前看运算符**，写作斜线（`/`）。

比如要识别`IF`，我们的正则表达式可以写为`IF / ( .* ) letter`，其中`.*`表示匹配任意字符任意多次，`letter`表示一个字母。
这表示匹配到`IF`之后，再向前看几个字符，只有斜线前后都被匹配时才表明匹配了这个语法单元，但是斜线之后的部分*不是这个词素的一部分*。

在构造自动机时，我们直接把斜线当作空串处理。
而在发生匹配时，我们必须仔细寻找满足以下四点的状态`s`：

1. 在`s`上存在一个空串的转换；
2. 对给定的输入，存在一个从开始状态到`s`的转换，匹配输入的一个前缀；
3. 对给定的输入，存在一个从`s`到接受状态的转换，匹配输入的一个后缀；
4. 如果存在多个满足以上条件的状态，选择前缀最长者。

此时我们把从开始状态到`s`状态所经过的边的标号连接起来，形成输入的一个前缀，这个前缀才是匹配的词素。

如果在这个`s`状态上只有一个代表`/`的空串转换，那么词素的末尾就是最后一次进入该状态的位置。
如果存在多个这样的转换，则识别会相当复杂。

对DFA的实现，一个简单的思路就是把正则表达式分为`r1/r2`两个部分，分别为`r1r2`和`r1`构造自动机，只有识别到`r1r2`后再识别`r1`。
但这种算法也有一些问题，尤其不能处理`r1`和`r2`有重合的情况，比如对`a*/a`这个模式，如果使用这个方法就会识别出额外的字符。

关于向前看（以及某些正则表达式引擎中支持的向后看）运算符的更多内容，可参考[这篇讨论](https://cs.stackexchange.com/q/2557)。

## 有穷自动机的优化

### 重要状态与几个函数

### 从正则表达式构建DFA

### DFA的状态最小化

#### 词法分析器的状态最小化

### 更好的转换表表示法

## 结语

这篇文章，连同此前两篇，构成了构建基本的词法分析器的所有理论知识。
我们以正则表达式为核心，介绍了识别它们的方式和如何利用它们构造词法分析器。
关于正则表达式的更多内容，可参见[这些博客](https://swtch.com/~rsc/regexp/)。
如果不想亲自编写一个用来识别词素的语法分析器，可以使用`lex`或`flex`工具，这些内容不在这篇文章的范围之内。
想要构造一个编译器的前端，还有语法分析相关内容，这一部分就是下几篇文章的内容了。
