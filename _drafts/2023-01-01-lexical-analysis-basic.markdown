---
layout: post
title: "词法分析——基础内容"
---

## 基本定义

词法分析是编译器前端的第一阶段，它负责将文本输入转化为词素并提供给语法分析器。
除此之外，词法分析器通常还负责将无用的注释和空白符去掉，将语法分析产生的错误对应到正确的位置，偶尔还负责将宏展开。

在讨论词法分析时，我们使用以下这些名词：

- **词法单元**是一个表示某种词法单位（比如一个关键字）的抽象符号，通常由词法单元名和属性构成。
我们使用黑体字$\mathbf{lex}$表示一个词法单元。
- **词素**是源程序中的一个字符串，是某个词法单元的实例。
- **模式**表示词法单元的词素所具有的形式。
如果一个字符串和某个词法单元的模式匹配，那么它就是这个词法单元的一个实例。
{: .definition}

例如，C语言中的字符串字面量$\mathbf{literal}$的模式就是被双引号包括的字符串，而`"string"`就是其一个词素。

通常语言中的词法单元分为五类：
1. 关键字：一般每个关键字对应一个词法单元；
2. 运算符：可以每个运算符对应一个词法单元，也可以一类运算符对应一个词法单元；
3. 标识符：变量名、函数名和类型名等标识符通常对应一个词法单元（和符号表内的条目）；
4. 字面量：整数、浮点数和字符串常量等通常对应一个词法单元；
5. 分隔符：左右括号、逗号和分号（甚至空格）通常对应一个词法单元。

如果多个不同的词素可以和同一模式匹配（如`+`、`-`都是运算符、`114`、`514`都是数字），那么需要额外的信息来区别它们。
因此，除了词法单元名之外，词法分析器还需要为语法分析提供额外的信息。
这种信息就是词法单元的属性。
特别地，对于标识符$\mathbf{id}$来说，其词法单元通常对应符号表中的一个条目，而信息一般放在符号表中，而非词法单元的属性中。
这些信息通常包括其词素（即标识符的名字）、类型和初次出现的位置，其生命周期贯穿整个编译始终，甚至在链接时也会大量使用。

词法分析器很难独自发现程序中的错误，因为其对程序的了解实在有限。
但是如果源程序不能和任何一个模式匹配，那么显然出现了错误。
词法分析器有多种处理错误的方式，最常见的错误恢复策略称为“恐慌模式”恢复，即从剩余输入中不断删去字符直到可以进行匹配为止。

## 正则表达式

在本节中，我们将形式化地定义正则表达式，并用它来表示词法单元的模式。
虽然正则表达式不能表示所有模式，但对于计算机程序来说已经绰绰有余了。

我们先给出几个基本的定义。

- **字母表**是一个*有限*的符号的集合。
- 字母表上的**字符串**，简称**串**，是此字母表中符号的一个*有限序列*。
串$s$的长度，记为$\|s\|$，是其中含有的符号的个数。
长度为零的串称为空串，记为$\epsilon$。
- **形式语言**，或简称**语言**，是给定字母表上任意*可数*的串的集合。
{: .definition}

这个语言的定义是相当宽泛的，比如空集和仅含空串的集合都是语言。
不严格地说，所有语法正确的自然语言组成的句子的集合也是形式语言。

在处理串时我们会经常使用以下术语：

- 前缀；
- 后缀；
- 字串；
- 真前缀、真后缀、真子串；
- 子序列；
- 连接。

这些术语和其在算法设计中的通常定义没有区别。
需要注意的是，空串是连接运算的单位元，任何串在前面或后面连接空串都能得到原串。

### 语言的运算

我们先定义语言之间的运算：

两个语言的**连接**就是以两个语言按顺序取串并连接形成的新串组成的语言。
形式化地说，设$L, M$为两个语言，那么其连接为：
$$
LM = \left\{ st \; \middle| \; s \in L , \; t \in M \right\}
$$
此外，我们递归地定义
$$
L^{i} = L^{i-1} L, \quad L^0 = \{ \epsilon \}
$$
两个语言的**并**即这两个集合的并。
形式化地说，设$L, M$为两个语言，那么其并为：
$$
L \cup M = \left\{ s \; \middle| \; s \in L \; \mathrm{or} \; s \in M \right\}
$$
语言的**克莱尼星号**（Kleene star，也称克莱尼闭包）为其所有次幂的并：
$$
L^* = \bigcup_{i=0}^\infty L^i
$$
语言的**克莱尼加号**，或称正闭包，为其所有*非零*幂次的并：
$$
L^+ = \bigcup_{i=1}^\infty L^i
$$
{: .definition}

如果我们设$L$表示所有字母的集合，那么$L^4$表示所有四个字母的串组成的集合，$L^\*$表示所有由字母组成的串组成的集合（含空串）。

如果熟悉正则表达式，不难发现，正则表达式中的星号和加号表示的是同样的意思。

### 正则表达式的形式定义

我们设$L(a)$表示正则表达式$a$所表示的语言，
用以下归纳法递归地给出正则表达式的形式定义：

- 归纳基础：
    1. $\epsilon$是一个正则表达式，且$L(\epsilon) = \\\{\epsilon\\\}$；
	2. 任何字母表中的单个字符构成一个正则表达式，其语言是其自身。
- 归纳步骤：设$r,s$为两个的正则表达式，那么：
	1. $(r)\|(s)$是一个正则表达式，表示$L(r) \cup L(s)$；
	2. $(r)(s)$是一个正则表达式，表示$L(r) L(s)$；
	3. $(r)^\*$是一个正则表达式，表示$L(r)^\*$；
	4. $(r)$是一个正则表达式，表示$L(r)$，即在正则表达式两侧加上括号对其没有影响。
{: .definition}

接下来，我们规定，克莱尼星号具有最高的优先级，连接运算次之，并运算最低，且都是左结合的。
那么，我们可以省掉一些括号：
如$(a) \| ((b)^\*(c))$就和$a \| b^\* c$规定了同一种语言。

可以用正则表达式表示的语言称为*正则语言*，如果两个正则表达式表示的语言相同，那么称其为**等价**的，记为$r = s$。

承接上文关于语言的运算的定义，我们可以发现正则表达式之间的运算满足一些代数性质：

- 并运算是可交换、可结合的：$r \| s = s \| r, \; r \| (s \| t) = (r \| s) \| t$；
- 连接运算是可结合的：$(rs)t = r(st)$；
- 连接运算关于并运算是左右可分配的：$r(s\|t) = rs \| rt \quad (s\|t)r = sr \| tr$；
- 空串是连接运算的单位元：$\epsilon r = r \epsilon = r$；
- 克莱尼星号具有幂等性：$r^{\*\*} = r^\*$。
{: .proposition}

### 正则定义

为了给正则表达式命名，我们引入**正则定义**的概念：

设$\Sigma$为一字母表，那么**正则定义**是具有以下形式的定义序列：
$$
\begin{aligned}
d_1 &\to r_1 \\
d_2 &\to r_2 \\
&\vdots \\
d_n &\to r_n
\end{aligned}
$$
其中，$d\_1, d\_2, \dots , d\_n \not\in \Sigma$，且$r\_i \in \Sigma \cup \\\{ d\_1, d\_2, \dots , d\_{i-1} \\\} $。
{: .definition}

我们规定第$i$项只能使用此前的定义，以避免循环定义的问题。
显然，我们可以通过递归地将$d_i$替换成其定义来把所有正则表达式转化为在$\Sigma$这一字母表上的表达式。

比方说，以下正则定义中的$id$就是C语言标识符的模式：
$$
\begin{aligned}
letter\_ &\to A | a | B | b | \cdots | Z | z | \_ \\
digit &\to 0 | 1 | \cdots | 9 \\
id &\to letter\_ (letter\_ | digit)^*
\end{aligned}
$$
{: .exampl}

### 正则表达式的拓展

现在各种程序设计语言中可用的正则表达式和上文介绍的大同小异，只是通常提供了几个拓展：

- 匹配一次或多次（`+`）：类比克莱尼加号，我们为正则表达式附加一个加法预算，规定$(r)^+$对应的语言为$(L(r))^+$；
- 匹配一次或零次（`?`）：规定$(r)?$对应的语言为$(L(r)) \cup \\\{ \epsilon \\\}$，这两个运算的优先级和结合性和星号相同；
- 字符类：几乎所有正则表达式语言都提供表示或运算的简便方式，比如通常`[a-b]`就表示$a\|b\| \cdots \|z$；
- 助记符：诸如`^`通常表示取反匹配、`$`通常表示匹配行末等。

## 识别模式

我们已经给出了利用正则表达式描述模式的方法，接下来需要解决的问题就是如何判定一个字符串是否匹配某一模式。

为方便起见，我们假设语言的所有关键字都是*保留字*，即虽然关键字可以和其他模式（如标识符）匹配，但总是把它们当作关键字而非其他词法单元。
我们还规定词法分析器会“吃掉”所有空白符，即空白符不会进入语法分析，这是通过让其识别词法单元`ws`做到的：
$$
ws \; \to \; ( \, \text{空格} \, | \, \text{制表符} \, | \, \text{换行符} \, )^*
$$

接下来我们规定以下正则定义，用来作为识别的例子：
$$
\begin{aligned}
digit &\to \mathrm{[0-9]} \\
digits &\to digit^+ \\
number &\to digits \; (. \; digits)? (\mathrm{E} \; [+-]? \; digits)? \\
letter &\to \mathrm{[A-Za-z]} \\
id &\to letter \; (letter|digit)^* \\
if &\to \mathrm{if} \\
then &\to \mathrm{then} \\
else &\to \mathrm{else} \\
relop &\to \mathrm{<} | \mathrm{>} | \mathrm{<=} | \mathrm{>=} | \mathrm{=} | \mathrm{<>}
\end{aligned}
$$
此外，我们希望对任意`number`和`id`词素，其属性都是其在符号表中对应条目的指针。
对任意`relop`词素，其属性都是其运算符的名字，依次为：`LT`、`GT`、`LE`、`GE`、`EQ`、`NE`。

### 状态转移图

为了方便讨论，我们假设整个源程序被整个读入无限大的缓冲区之中。
我们附加两个指针，`lexemeBegin`表示目前这个词素的开始位置，而词法分析器希望找到这个词素的结尾；
`forward`指针表示当前正在处理的字符的位置，它将不断前进直到可以确定这个词素的结尾。
发现结尾之后，`lexemeBegin`将移动至`forward`指针的位置，以便处理下一个词素。

为了处理正则表达式的识别，我们提出**状态转移图**：

**状态转移图**是这样一张有向图：
其结点表示一个*状态*，其边带有标号。
如果当前处于某个状态，且发现下一个字符，那么如果存在从该状态出发且标号和此字符相同的边，那么将向其所指向的状态移动。
如果对任意的状态和任意的字符，满足上述条件的边至多只有一条，那么我们称其为**确定**的。
{: .definition}

某些特别的状态称为**接受状态**或**终止状态**，如果当前状态到达这些状态，那么说明已经找到一个词素的末尾。
如果我们需要词法分析做出某些动作，那么这些动作的代码也写在该状态旁。

有些时候，我们希望将`forward`指针退回，这可能是因为词素并不包含到达终止状态之前那一个字符。
如果我们希望退回这个指针，那么我们在状态旁以星号标记。
有几个星号就将指针退回几次。

