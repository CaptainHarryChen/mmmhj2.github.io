---
layout: post
title: "词法分析——基础内容"
---

## 基本定义

词法分析是编译器前端的第一阶段，它负责将文本输入转化为词素并提供给语法分析器。
除此之外，词法分析器通常还负责将无用的注释和空白符去掉，将语法分析产生的错误对应到正确的位置，偶尔还负责将宏展开。

在讨论词法分析时，我们使用以下这些名词：

- **词法单元**是一个表示某种词法单位（比如一个关键字）的抽象符号，通常由词法单元名和属性构成。
我们使用黑体字$\mathbf{lex}$表示一个词法单元。
- **词素**是源程序中的一个字符串，是某个词法单元的实例。
- **模式**表示词法单元的词素所具有的形式。
如果一个字符串和某个词法单元的模式匹配，那么它就是这个词法单元的一个实例。
{: .definition}

例如，C语言中的字符串字面量$\mathbf{literal}$的模式就是被双引号包括的字符串，而`"string"`就是其一个词素。

通常语言中的词法单元分为五类：
1. 关键字：一般每个关键字对应一个词法单元；
2. 运算符：可以每个运算符对应一个词法单元，也可以一类运算符对应一个词法单元；
3. 标识符：变量名、函数名和类型名等标识符通常对应一个词法单元（和符号表内的条目）；
4. 字面量：整数、浮点数和字符串常量等通常对应一个词法单元；
5. 分隔符：左右括号、逗号和分号（甚至空格）通常对应一个词法单元。

如果多个不同的词素可以和同一模式匹配（如`+`、`-`都是运算符、`114`、`514`都是数字），那么需要额外的信息来区别它们。
因此，除了词法单元名之外，词法分析器还需要为语法分析提供额外的信息。
这种信息就是词法单元的属性。
特别地，对于标识符$\mathbf{id}$来说，其词法单元通常对应符号表中的一个条目，而信息一般放在符号表中，而非词法单元的属性中。
这些信息通常包括其词素（即标识符的名字）、类型和初次出现的位置，其生命周期贯穿整个编译始终，甚至在链接时也会大量使用。

词法分析器很难独自发现程序中的错误，因为其对程序的了解实在有限。
但是如果源程序不能和任何一个模式匹配，那么显然出现了错误。
词法分析器有多种处理错误的方式，最常见的错误恢复策略称为“恐慌模式”恢复，即从剩余输入中不断删去字符直到可以进行匹配为止。

## 正则表达式

在本节中，我们将形式化地定义正则表达式，并用它来表示词法单元的模式。
虽然正则表达式不能表示所有模式，但对于计算机程序来说已经绰绰有余了。

我们先给出几个基本的定义。

- **字母表**是一个*有限*的符号的集合。
- 字母表上的**字符串**，简称**串**，是此字母表中符号的一个*有限序列*。
串$s$的长度，记为$\|s\|$，是其中含有的符号的个数。
长度为零的串称为空串，记为$\epsilon$。
- **形式语言**，或简称**语言**，是给定字母表上任意*可数*的串的集合。
{: .definition}

这个语言的定义是相当宽泛的，比如空集和仅含空串的集合都是语言。
不严格地说，所有语法正确的自然语言组成的句子的集合也是形式语言。

在处理串时我们会经常使用以下术语：

- 前缀；
- 后缀；
- 字串；
- 真前缀、真后缀、真子串；
- 子序列；
- 连接。

这些术语和其在算法设计中的通常定义没有区别。
需要注意的是，空串是连接运算的单位元，任何串在前面或后面连接空串都能得到原串。

### 语言的运算

我们先定义语言之间的运算：

两个语言的**连接**就是以两个语言按顺序取串并连接形成的新串组成的语言。
形式化地说，设$L, M$为两个语言，那么其连接为：
$$
LM = \left\{ st \; \middle| \; s \in L , \; t \in M \right\}
$$
此外，我们递归地定义
$$
L^{i} = L^{i-1} L, \quad L^0 = \{ \epsilon \}
$$
两个语言的**并**即这两个集合的并。
形式化地说，设$L, M$为两个语言，那么其并为：
$$
L \cup M = \left\{ s \; \middle| \; s \in L \; \mathrm{or} \; s \in M \right\}
$$
语言的**克莱尼星号**（Kleene star，也称克莱尼闭包）为其所有次幂的并：
$$
L^* = \bigcup_{i=0}^\infty L^i
$$
语言的**克莱尼加号**，或称正闭包，为其所有*非零*幂次的并：
$$
L^+ = \bigcup_{i=1}^\infty L^i
$$
{: .definition}

如果我们设$L$表示所有字母的集合，那么$L^4$表示所有四个字母的串组成的集合，$L^\*$表示所有由字母组成的串组成的集合（含空串）。

如果熟悉正则表达式，不难发现，正则表达式中的星号和加号表示的是同样的意思。

### 正则表达式的形式定义

我们设$L(a)$表示正则表达式$a$所表示的语言，
用以下归纳法递归地给出正则表达式的形式定义：

- 归纳基础：
    1. $\epsilon$是一个正则表达式，且$L(\epsilon) = \\\{\epsilon\\\}$；
	2. 任何字母表中的单个字符构成一个正则表达式，其语言是其自身。
- 归纳步骤：设$r,s$为两个的正则表达式，那么：
	1. $(r)\|(s)$是一个正则表达式，表示$L(r) \cup L(s)$；
	2. $(r)(s)$是一个正则表达式，表示$L(r) L(s)$；
	3. $(r)^\*$是一个正则表达式，表示$L(r)^\*$；
	4. $(r)$是一个正则表达式，表示$L(r)$，即在正则表达式两侧加上括号对其没有影响。
{: .definition}

接下来，我们规定，克莱尼星号具有最高的优先级，连接运算次之，并运算最低，且都是左结合的。
那么，我们可以省掉一些括号：
如$(a) \| ((b)^\*(c))$就和$a \| b^\* c$规定了同一种语言。

可以用正则表达式表示的语言称为*正则语言*，如果两个正则表达式表示的语言相同，那么称其为**等价**的，记为$r = s$。

承接上文关于语言的运算的定义，我们可以发现正则表达式之间的运算满足一些代数性质：

- 并运算是可交换、可结合的：$r \| s = s \| r, \; r \| (s \| t) = (r \| s) \| t$；
- 连接运算是可结合的：$(rs)t = r(st)$；
- 连接运算关于并运算是左右可分配的：$r(s\|t) = rs \| rt \quad (s\|t)r = sr \| tr$；
- 空串是连接运算的单位元：$\epsilon r = r \epsilon = r$；
- 克莱尼星号具有幂等性：$r^{\*\*} = r^\*$。
{: .proposition}

### 正则定义

为了给正则表达式命名，我们引入**正则定义**的概念：

设$\Sigma$为一字母表，那么**正则定义**是具有以下形式的定义序列：
$$
\begin{aligned}
d_1 &\to r_1 \\
d_2 &\to r_2 \\
&\vdots \\
d_n &\to r_n
\end{aligned}
$$
其中，$d\_1, d\_2, \dots , d\_n \not\in \Sigma$，且$r\_i \in \Sigma \cup \\\{ d\_1, d\_2, \dots , d\_{i-1} \\\} $。
{: .definition}

我们规定第$i$项只能使用此前的定义，以避免循环定义的问题。
显然，我们可以通过递归地将$d_i$替换成其定义来把所有正则表达式转化为在$\Sigma$这一字母表上的表达式。
